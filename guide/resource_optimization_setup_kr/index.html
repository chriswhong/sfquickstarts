
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>리소스 최적화: 설정 및 구성</title>

  
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-5Q8R2G');</script>
  

  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-08H27EW14N"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-08H27EW14N');
</script>

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://quickstarts.snowflake.com/elements/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5Q8R2G"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  
  <google-codelab-analytics gaid="UA-41491190-9"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="resource_optimization_setup_kr"
                  title="리소스 최적화: 설정 및 구성"
                  environment="web"
                  feedback-link="https://github.com/Snowflake-Labs/sfguides/issues">
    
      <google-codelab-step label="개요" duration="0">
        <p>이 리소스 최적화 가이드는 해당 시리즈에 포함되어 있는 4개의 모듈 중 하나를 나타냅니다. 이러한 가이드는 고객이 자신의 크레딧 소비를 더 잘 모니터링하고 관리할 수 있도록 돕는 것을 목적으로 합니다. 고객이 자신의 크레딧이 효율적으로 사용되고 있다는 것을 자신할 수 있도록 돕는 것은 지속적이며 성공적인 파트너십에 중요합니다. 이 리소스 최적화를 위한 Snowflake 빠른 시작 세트와 더불어 Snowflake는 커뮤니티 지원, 교육 및 프로페셔널 서비스를 제공합니다. 유료 서비스에 대한 자세한 내용은 다가오는 <a href="https://www.snowflake.com/education-and-training/" target="_blank">훈련 및 교육</a>에서 확인하십시오.</p>
<p>이 <a href="https://www.snowflake.com/blog/understanding-snowflakes-resource-optimization-capabilities/" target="_blank">블로그 포스트</a>는 여러분이 Snowflake의 리소스 최적화 기능을 더 잘 이해할 수 있도록 합니다.</p>
<p><a href="mailto:marketing@snowflake.com" target="_blank">marketing@snowflake.com</a>으로 Snowflake 팀에 문의하십시오. Snowflake는 여러분의 피드백을 소중하게 여깁니다.</p>
<h2 is-upgraded>설정 및 구성</h2>
<p>설정 및 구성 쿼리는 폭주 리소스 및 비용 소비를 방지할 수 있는 주요 기능을 활용하지 않는 웨어하우스에 대한 더 많은 선제적인 통찰력을 제공합니다.  아래 나열된 주요 쿼리를 활용하여 적절한 기능을 활용하기 위해 재구성할 수 있는 웨어하우스를 확인하십시오.</p>
<h2 is-upgraded>학습할 내용</h2>
<ul>
<li>Snowflake 소비 제어를 위해 사용 가능한 기능 및 설정</li>
<li>자동 일시 중단 및 자동 재개 구성의 중요성</li>
<li>관련 있는 문 시간제한 구성 방법</li>
<li>리소스 모니터의 값 및 구성</li>
<li>사용자 활동 분석 방법</li>
<li>작업 동작 분석 방법</li>
</ul>
<h2 is-upgraded>필요한 것</h2>
<ul>
<li><a href="https://www.snowflake.com/" target="_blank">Snowflake</a> 계정</li>
<li><a href="https://docs.snowflake.com/ko/sql-reference/account-usage.html#enabling-account-usage-for-other-roles" target="_blank">계정 사용량 데이터 공유</a>를 보기 위한 액세스</li>
</ul>
<h2 is-upgraded>관련 자료</h2>
<ul>
<li>리소스 최적화: 사용량 모니터링</li>
<li>리소스 최적화: 청구 메트릭</li>
<li>리소스 최적화: 성능</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="쿼리 Tiers" duration="0">
        <p>리소스 최적화 Snowflake 빠른 시작 내에 있는 각 쿼리 이름의 오른쪽에는 ‘(T*)&#39;로 tier 지정이 있습니다.  다음 tier 설명은 이러한 지정을 더 잘 이해하는 데 도움이 됩니다.</p>
<h2 is-upgraded>Tier 1 쿼리</h2>
<p>본질적으로 Tier 1 쿼리는 Snowflake의 리소스 최적화에 매우 중요합니다. 또한 각 고객이 규모, 업계, 위치 등에 관계없이 자신의 소비 모니터링에 대해 도움을 받기 위해 사용해야 합니다.</p>
<h2 is-upgraded>Tier 2 쿼리</h2>
<p>Tier 2 쿼리는 리소스 최적화에 대한 추가적인 깊이를 제공하는 동시에 프로세스에서 중요한 역할을 수행합니다. 또한 모든 고객과 고객의 워크로드에 필수적이지는 않을지라도 과도한 소비가 확인되었을 수 있는 모든 추가 영역에 대한 추가적인 설명을 제공할 수 있습니다.</p>
<h2 is-upgraded>Tier 3 쿼리</h2>
<p>마지막으로 Tier 3 쿼리는 Snowflake 소비를 최적화하는 데 있어서 모든 부분을 확인하고자 하는 고객이 사용할 수 있도록 설계되었습니다.  이러한 쿼리는 이 프로세스에서 여전히 매우 유용하지만 Tier 1 및 2의 쿼리만큼 중요하지는 않습니다.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Warehouses without Auto-Resume (T1)" duration="0">
        <h5 is-upgraded>Tier 1</h5>
<h3 is-upgraded>설명:</h3>
<p>자동 재개가 활성화되어 있지 않은 모든 웨어하우스를 식별합니다.  이 기능을 활성화하면 쿼리가 특정 웨어하우스에 제출될 때마다 웨어하우스를 자동으로 재개합니다. 기본값으로 모든 웨어하우스에는 자동 재개가 활성화되어 있습니다.</p>
<h3 is-upgraded>결과 해석 방법:</h3>
<p>모든 웨어하우스에 자동 재개가 설정되어 있음을 확인하십시오.  자동 일시 중단 및 적절한 시간제한 한도를 적용할 예정이라면 이는 필수적입니다. 이를 수행하지 않으면 사용자는 시스템을 쿼리할 수 없습니다.</p>
<h3 is-upgraded>SQL</h3>
<pre><code language="language-sql" class="language-sql">SHOW WAREHOUSES
;
SELECT &#34;name&#34; AS WAREHOUSE_NAME
      ,&#34;size&#34; AS WAREHOUSE_SIZE
  FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
 WHERE &#34;auto_resume&#34; = &#39;false&#39;
;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Warehouses without Auto-Suspend (T1)" duration="0">
        <h5 is-upgraded>Tier 1</h5>
<h3 is-upgraded>설명:</h3>
<p>자동 일시 중단이 활성화되어 있지 않은 모든 웨어하우스를 식별합니다.  이 기능을 활성화하면 폭주 비용을 방지하기 위해 특정 기간 동안 비활성 시간이 지속된 후 웨어하우스가 일시 중단되는 것이 보장될 것입니다.  기본값으로 모든 웨어하우스에는 자동 일시 중단이 활성화되어 있습니다.</p>
<h3 is-upgraded>결과 해석 방법:</h3>
<p>모든 웨어하우스에 자동 일시 중단이 설정되어 있음을 확인하십시오. 이를 통해 쿼리가 처리되지 않을 때 여러분의 컴퓨팅 공간이 축소되며 크레딧 소비가 줄어듭니다.</p>
<h3 is-upgraded>SQL</h3>
<pre><code language="language-sql" class="language-sql">SHOW WAREHOUSES
;
SELECT &#34;name&#34; AS WAREHOUSE_NAME
      ,&#34;size&#34; AS WAREHOUSE_SIZE
  FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
 WHERE IFNULL(&#34;auto_suspend&#34;,0) = 0
;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Warehouses with Long Suspension (T1)" duration="0">
        <h5 is-upgraded>Tier 1</h5>
<h3 is-upgraded>설명:</h3>
<p>해당 웨어하우스에서 활동이 없는 기간 후 가장 긴 자동 일시 중단 설정을 가진 웨어하우스를 식별합니다.</p>
<h3 is-upgraded>결과 해석 방법:</h3>
<p>모든 웨어하우스에는 워크로드를 위해 자동 일시 중단에 대한 적절한 설정이 있어야 합니다.</p>
<p>– Tasks, Loading 및 ETL/ELT 웨어하우스의 경우 즉각적인 일시 중단을 설정합니다.</p>
<p>– BI 및 SELECT 쿼리 웨어하우스의 경우 최종 사용자를 위해 데이터 캐시를 예열된 상태로 유지할 수 있도록 일시 중단을 10분으로 설정합니다</p>
<p>– DevOps, DataOps 및 Data Science 웨어하우스의 경우 예열된 캐시가 애드혹 및 고유한 쿼리에 그렇게 중요하지 않기에 일시 중단을 5분으로 설정합니다.</p>
<h3 is-upgraded>SQL</h3>
<pre><code language="language-sql" class="language-sql">SHOW WAREHOUSES
;
SELECT &#34;name&#34; AS WAREHOUSE_NAME
      ,&#34;size&#34; AS WAREHOUSE_SIZE
  FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
 WHERE &#34;auto_suspend&#34; &gt;= 3600  // 3600 seconds = 1 hour
;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Warehouses without Resource Monitors (T1)" duration="0">
        <h5 is-upgraded>Tier 1</h5>
<h3 is-upgraded>설명:</h3>
<p>리소스 모니터가 배치되어 있지 않은 모든 웨어하우스를 식별합니다.  리소스 모니터는 특정 시간 간격 또는 날짜 범위 동안 웨어하우스에서 소비되는 크레딧의 한도를 지정하는 능력을 제공합니다.  이는 특정 웨어하우스가 의도치 않게 예측한 것보다 더 많은 크레딧을 소비하는 것을 방지하는 데 도움이 될 수 있습니다.</p>
<h3 is-upgraded>결과 해석 방법:</h3>
<p>리소스 모니터가 배치되어 있지 않은 웨어하우스는 예측했던 것보다 더 많은 크레딧을 소비할 때 과도한 비용을 초래할 가능성이 높습니다.  이 쿼리의 결과를 활용하여 추가적인 폭주 비용을 방지하기 위해 리소스 모니터가 배치되어 있어야 하는 웨어하우스를 식별합니다.</p>
<h3 is-upgraded>SQL</h3>
<pre><code language="language-sql" class="language-sql">SHOW WAREHOUSES
;
SELECT &#34;name&#34; AS WAREHOUSE_NAME
      ,&#34;size&#34; AS WAREHOUSE_SIZE
  FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
 WHERE &#34;resource_monitor&#34; = &#39;null&#39;
;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="User Segmentation (T1)" duration="0">
        <h5 is-upgraded>Tier 1</h5>
<h3 is-upgraded>설명:</h3>
<p>Snowflake에서 여러 역할에 의해 사용되고 있는 모든 웨어하우스를 목록으로 나열하며 각 웨어하우스에서 각 역할에 의해 실행되는 모든 쿼리의 평균 실행 시간과 카운트를 반환합니다.</p>
<h3 is-upgraded>결과 해석 방법:</h3>
<p>실행 시간 또는 쿼리 카운트가 단일 웨어하우스 내 여러 역할에 걸쳐 크게 다르다면 이러한 사용자를 별도의 웨어하우스로 분할하고 각 워크로드의 특정 요구 사항을 충족하기 위해 각 웨어하우스를 구성하는 것이 가치가 있을지도 모릅니다</p>
<h3 is-upgraded>주요 스키마:</h3>
<p>Account_Usage</p>
<h3 is-upgraded>SQL</h3>
<pre><code language="language-sql" class="language-sql">SELECT *

FROM (
  SELECT 

  WAREHOUSE_NAME
  ,ROLE_NAME
  ,AVG(EXECUTION_TIME) as AVERAGE_EXECUTION_TIME
  ,COUNT(QUERY_ID) as COUNT_OF_QUERIES
  ,COUNT(ROLE_NAME) OVER(PARTITION BY WAREHOUSE_NAME) AS ROLES_PER_WAREHOUSE


  FROM &#34;SNOWFLAKE&#34;.&#34;ACCOUNT_USAGE&#34;.&#34;QUERY_HISTORY&#34;
  where to_date(start_time) &gt;= dateadd(month,-1,CURRENT_TIMESTAMP())
  group by 1,2
) A
WHERE A.ROLES_PER_WAREHOUSE &gt; 1
order by 5 DESC,1,2
;
</code></pre>
<h3 is-upgraded>스크린샷</h3>
<p class="image-container"><img alt="alt-tlext-here" src="img/5fe3c0415c85e53e.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Idle Users (T2)" duration="0">
        <h5 is-upgraded>Tier 2</h5>
<h3 is-upgraded>설명:</h3>
<p>지난 30일간 로그인하지 않은 Snowflake 플랫폼에 있는 사용자입니다</p>
<h3 is-upgraded>결과 해석 방법:</h3>
<p>이러한 사용자가 삭제되어야 하나요 아니면 공식적으로 온보딩되어야 하나요?</p>
<h3 is-upgraded>주요 스키마:</h3>
<p>Account_Usage</p>
<h3 is-upgraded>SQL</h3>
<pre><code language="language-sql" class="language-sql">SELECT 
	*
FROM SNOWFLAKE.ACCOUNT_USAGE.USERS 
WHERE LAST_SUCCESS_LOGIN &lt; DATEADD(month, -1, CURRENT_TIMESTAMP()) 
AND DELETED_ON IS NULL;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Users Never Logged In (T2)" duration="0">
        <h5 is-upgraded>Tier 2</h5>
<h3 is-upgraded>설명:</h3>
<p>Snowflake에 한 번도 로그인하지 않은 사용자입니다</p>
<h3 is-upgraded>결과 해석 방법:</h3>
<p>이러한 사용자가 삭제되어야 하나요 아니면 공식적으로 온보딩되어야 하나요?</p>
<h3 is-upgraded>주요 스키마:</h3>
<p>Account_Usage</p>
<h3 is-upgraded>SQL</h3>
<pre><code language="language-sql" class="language-sql">SELECT 
	*
FROM SNOWFLAKE.ACCOUNT_USAGE.USERS 
WHERE LAST_SUCCESS_LOGIN IS NULL;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Idle Roles (T2)" duration="0">
        <h5 is-upgraded>Tier 2</h5>
<h3 is-upgraded>설명:</h3>
<p>지난 30일간 사용되지 않은 역할입니다</p>
<h3 is-upgraded>결과 해석 방법:</h3>
<p>이러한 역할이 필요한가요? 이러한 역할이 정리되어야 하나요?</p>
<h3 is-upgraded>주요 스키마:</h3>
<p>Account_Usage</p>
<h3 is-upgraded>SQL</h3>
<pre><code language="language-sql" class="language-sql">SELECT 
	R.*
FROM SNOWFLAKE.ACCOUNT_USAGE.ROLES R
LEFT JOIN (
    SELECT DISTINCT 
        ROLE_NAME 
    FROM SNOWFLAKE.ACCOUNT_USAGE.QUERY_HISTORY 
    WHERE START_TIME &gt; DATEADD(month,-1,CURRENT_TIMESTAMP())
        ) Q 
                ON Q.ROLE_NAME = R.NAME
WHERE Q.ROLE_NAME IS NULL
and DELETED_ON IS NULL;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Idle Warehouses (T2)" duration="0">
        <h5 is-upgraded>Tier 2</h5>
<h3 is-upgraded>설명:</h3>
<p>지난 30일간 사용되지 않은 웨어하우스입니다</p>
<h3 is-upgraded>결과 해석 방법:</h3>
<p>이러한 웨어하우스가 삭제되어야 하나요? 이러한 웨어하우스의 사용자가 활성화/온보딩되어야 하나요?</p>
<h3 is-upgraded>SQL</h3>
<pre><code language="language-sql" class="language-sql">SHOW WAREHOUSES;

select * 
from table(result_scan(last_query_id())) a
left join (select distinct WAREHOUSE_NAME from SNOWFLAKE.ACCOUNT_USAGE.WAREHOUSE_METERING_HISTORY 
    WHERE START_TIME &gt; DATEADD(month,-1,CURRENT_TIMESTAMP())
) b on b.WAREHOUSE_NAME = a.&#34;name&#34;

where b.WAREHOUSE_NAME is null;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Set Statement Timeouts (T2)" duration="0">
        <h5 is-upgraded>Tier 2</h5>
<h3 is-upgraded>설명:</h3>
<p>문 시간제한은 쿼리를 취소하기 전에 실행될 수 있는 시간에 대한 추가 제어를 제공합니다. 이 기능을 사용하면 긴 시간 동안 실행되는 모든 쿼리로 인해 크레딧이 과도하게 소비되지 않는 것이 보장됩니다.</p>
<p>Account, Warehouse 및 User Session 수준의 매개 변수 설정을 보여줍니다.</p>
<h3 is-upgraded>SQL</h3>
<pre><code language="language-sql" class="language-sql">SHOW PARAMETERS LIKE &#39;STATEMENT_TIMEOUT_IN_SECONDS&#39; IN ACCOUNT;
SHOW PARAMETERS LIKE &#39;STATEMENT_TIMEOUT_IN_SECONDS&#39; IN WAREHOUSE &lt;warehouse-name&gt;;
SHOW PARAMETERS LIKE &#39;STATEMENT_TIMEOUT_IN_SECONDS&#39; IN USER &lt;username&gt;;
</code></pre>
<h3 is-upgraded>결과 해석 방법:</h3>
<p>이 매개 변수는 기본값으로 계정 수준으로 설정됩니다.  또한 매개 변수가 웨어하우스와 사용자 세션 모두에 설정되었을 때 가장 낮은 0이 아닌 값이 시행됩니다.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Stale Table Streams (T2)" duration="0">
        <h5 is-upgraded>Tier 2</h5>
<h3 is-upgraded>설명:</h3>
<p>스트림을 위한 오프셋이 테이블을 위한 데이터 보존 기간(또는 14일, 더 긴 시간 기준) 이전에 배치되어 있는지를 나타냅니다. 변경 데이터 캡처(CDC) 활동은 테이블을 위해 반환될 수 없습니다.</p>
<h3 is-upgraded>결과 해석 방법:</h3>
<p>테이블을 위해 CDC 활동을 반환하려면 스트림을 재생성합니다. 스트림이 스테일 상태가 되지 않도록 테이블의 보존 기간 동안 트랜잭션 내 스트림 레코드를 소비합니다.</p>
<h3 is-upgraded>SQL</h3>
<pre><code language="language-sql" class="language-sql">SHOW STREAMS;

select * 
from table(result_scan(last_query_id())) 
where &#34;stale&#34; = true;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Failed Tasks (T2)" duration="0">
        <h5 is-upgraded>Tier 2</h5>
<h3 is-upgraded>설명:</h3>
<p>실패한 작성 실행 목록을 반환합니다.</p>
<h3 is-upgraded>결과 해석 방법:</h3>
<p>이러한 실행을 재방문하여 오류를 해결합니다.</p>
<h3 is-upgraded>주요 스키마:</h3>
<p>Account_Usage</p>
<h3 is-upgraded>SQL</h3>
<pre><code language="language-sql" class="language-sql">select *
  from snowflake.account_usage.task_history
  WHERE STATE = &#39;FAILED&#39;
  and query_start_time &gt;= DATEADD (day, -7, CURRENT_TIMESTAMP())
  order by query_start_time DESC
  ;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Long Running Tasks (T2)" duration="0">
        <h5 is-upgraded>Tier 2</h5>
<h3 is-upgraded>설명:</h3>
<p>가장 길게 실행되는 작업의 순서가 지정된 목록을 반환합니다</p>
<h3 is-upgraded>결과 해석 방법:</h3>
<p>최적화를 위해 작업 실행 빈도나 작업 코드를 재방문합니다</p>
<h3 is-upgraded>주요 스키마:</h3>
<p>Account_Usage</p>
<h3 is-upgraded>SQL</h3>
<pre><code language="language-sql" class="language-sql">select DATEDIFF(seconds, QUERY_START_TIME,COMPLETED_TIME) as DURATION_SECONDS
                ,*
from snowflake.account_usage.task_history
WHERE STATE = &#39;SUCCEEDED&#39;
and query_start_time &gt;= DATEADD (day, -7, CURRENT_TIMESTAMP())
order by DURATION_SECONDS desc
  ;
</code></pre>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/native-shim.js"></script>
  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/custom-elements.min.js"></script>
  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/prettify.js"></script>
  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>
  <script type="text/javascript">
    window.heap=window.heap||[],heap.load=function(e,t){window.heap.appid=e,window.heap.config=t=t||{};var r=t.forceSSL||"https:"===document.location.protocol,a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src=(r?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+e+".js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(a,n);for(var o=function(e){return function(){heap.push([e].concat(Array.prototype.slice.call(arguments,0)))}},p=["addEventProperties","addUserProperties","clearEventProperties","identify","removeEventProperty","setEventProperties","track","unsetEventProperty"],c=0;c<p.length;c++)heap[p[c]]=o(p[c])};
    heap.load("2025084205");
  </script>
</body>
</html>
