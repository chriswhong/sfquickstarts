
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Snowflake SQL API 시작하기</title>

  
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-5Q8R2G');</script>
  

  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-08H27EW14N"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-08H27EW14N');
</script>

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://quickstarts.snowflake.com/elements/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5Q8R2G"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  
  <google-codelab-analytics gaid="UA-41491190-9"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="getting_started_snowflake_sql_api_kr"
                  title="Snowflake SQL API 시작하기"
                  environment="web"
                  feedback-link="https://github.com/Snowflake-Labs/sfguides/issues">
    
      <google-codelab-step label="개요" duration="1">
        <p>환영합니다! Snowflake SQL API는 Snowflake 데이터에 있는 데이터에 액세스하고 업데이트하는 데 사용할 수 있는 <a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank">REST API</a>입니다. 이 API를 사용하여 <a href="https://docs.snowflake.com/ko/sql-reference/constructs.html" target="_blank">표준 쿼리</a>와 대부분의 <a href="https://docs.snowflake.com/ko/sql-reference/sql-ddl-summary.html" target="_blank">DDL</a> 및 <a href="https://docs.snowflake.com/ko/sql-reference/sql-dml.html" target="_blank">DML</a> 문을 실행할 수 있습니다.</p>
<p>이 시작하기 가이드는 API를 통해 SQL 문을 실행하고 결과를 검색하는 것을 안내합니다.</p>
<h2 is-upgraded>사전 필요 조건 및 지식</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=fEtoYweBNQ4" target="_blank">Snowflake</a>에 대한 이해</li>
<li>SQL에 대한 이해</li>
</ul>
<h2 is-upgraded>학습할 내용</h2>
<ul>
<li>단순한 쿼리 수행</li>
<li>배포(예: 사용자 및 역할 프로비저닝, 테이블 생성 등) 관리</li>
<li>API 호출당 실행을 위해 하나의 SQL 문 제출</li>
<li>문 실행 상태 확인</li>
<li>문 실행 취소</li>
</ul>
<h2 is-upgraded>필요한 것</h2>
<ul>
<li>접근 가능한 웨어하우스, 데이터베이스, 스키마 및 역할을 포함한 Snowflake 계정</li>
<li>SnowSQL 1.2.17 이상</li>
<li>작동하는 <a href="https://docs.snowflake.com/ko/user-guide/key-pair-auth.html#configuring-key-pair-authentication" target="_blank">키 쌍 인증</a></li>
</ul>
<h2 is-upgraded>구축할 것</h2>
<ul>
<li>Snowflake SQL API를 사용하여 문 실행</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="API 소개" duration="3">
        <p>다음 URL의 버전을 탐색하여 SQL API로 이동합니다. 여러분의 Snowflake 계정을 위한 계정 로케이터로 <code>*account_locator*</code>를 대체합니다.</p>
<pre><code>https://*account_locator*.snowflakecomputing.com/api/v2
</code></pre>
<p>Negative : 계정 로케이터에는 여러분의 지역 및 클라우드 공급자를 위한 추가 세그먼트가 포함되어 있을 수 있습니다. 자세한 사항은 <a href="https://docs.snowflake.com/ko/user-guide/intro-regions.html#label-region-ids" target="_blank">계정 호스트 이름에 지역 정보 지정</a>을 확인하십시오.</p>
<p>사용을 시작하기 전에 이제 API의 각 부분을 분석해 보겠습니다. API는 <code>/api/v2/statements/</code> 리소스로 구성되어 있으며 다음 엔드포인트를 제공합니다.</p>
<ul>
<li><code>/api/v2/statements</code>: 이 엔드포인트는 <a href="https://docs.snowflake.com/ko/developer-guide/sql-api/reference.html#post-api-v2-statements" target="_blank">실행을 위한 SQL 문을 제출</a>하기 위해 사용합니다.</li>
<li><code>/api/v2/statements/*statementHandle*</code>: 이 엔드포인트는 <a href="https://docs.snowflake.com/ko/developer-guide/sql-api/reference.html#get-api-v2-statements-statementhandle" target="_blank">문의 실행 상태를 확인</a>하기 위해 사용합니다.</li>
<li><code>/api/v2/statements/*statementHandle*/cancel</code>: 이 엔드포인트는 <a href="https://docs.snowflake.com/ko/developer-guide/sql-api/reference.html#post-api-v2-statements-statementhandle-cancel" target="_blank">문의 실행을 취소</a>하기 위해 사용합니다.</li>
</ul>
<p>다음 단계에서는 이러한 모든 엔드포인트를 사용하여 여러분이 API에 익숙해질 수 있도록 합니다.</p>
<p>Positive : REST API(예: Postman)를 위한 개발자 도구 및 라이브러리를 사용하여 요청을 전송하고 응답을 처리할 수 있습니다.</p>
<h2 is-upgraded>SQL API의 한계</h2>
<p>현존하는 <a href="https://docs.snowflake.com/ko/developer-guide/sql-api/guide.html#limitations-of-the-sql-api" target="_blank">SQL API의 한계</a>를 인지하고 있는 것이 중요합니다.  특히나 <code>GET</code> 및 <code>PUT</code>은 지원되지 않습니다.</p>


      </google-codelab-step>
    
      <google-codelab-step label="요청 재제출을 위해 고유한 요청 ID 할당" duration="1">
        <p>일부 경우 Snowflake가 API 요청에서 SQL 문을 실행했는지가 확실하지 않을 수 있습니다(예: 네트워크 오류 또는 시간제한으로 인해). Snowflake가 문을 실행하지 않았을 경우 Snowflake에 동일한 요청을 재제출하기로 결정할 수 있습니다.</p>
<p>Snowflake가 이미 초기 요청에서 문을 실행했는데 여러분이 요청을 재제출한다면 문은 두 번 실행됩니다. 일부 요청 유형의 경우 반복적으로 동일한 문을 실행하면 의도하지 않은 결과(예: 테이블에 중복 데이터 삽입)가 나타날 수 있습니다.</p>
<p>여러분이 요청을 재제출할 때 Snowflake가 동일한 문을 두 번 실행하는 것을 방지하기 위해 요청 ID를 사용하여 여러분의 요청을 다른 요청과 구별할 수 있습니다. 여러분이 초기 실행과 재제출 요청에 동일한 요청 ID를 지정했다고 가정하겠습니다. 이러한 경우 해당 문이 이미 성공적으로 실행되었다면 Snowflake는 문을 다시 실행하지 않습니다.</p>
<p>요청 ID를 지정하려면 <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier" target="_blank">UUID(Universally Unique Identifier)</a>를 생성하고 이 식별자를 <code>requestId</code> 쿼리 매개 변수에 포함합니다.</p>
<pre><code>POST /api/v2/statements?requestId=&lt;UUID&gt; HTTP/1.1
</code></pre>
<p>Snowflake가 요청을 처리하는 데 실패하면 동일한 요청 ID로 동일한 요청을 다시 제출할 수 있습니다. 동일한 요청 ID를 사용하는 것은 서버에 여러분이 동일한 요청을 다시 제출하고 있음을 알립니다.</p>
<p>이제 요청에 포함해야 하는 추가 정보인 인증 매개 변수에 대해 알아보겠습니다.</p>


      </google-codelab-step>
    
      <google-codelab-step label="서버에 인증" duration="3">
        <p>요청을 전송할 때 요청에는 인증 정보가 반드시 포함되어야 합니다. 인증을 제공하는 2가지 옵션은 OAuth 및 JWT 키 쌍 인증입니다. 둘 중 이전에 구현했던 것이나 가장 익숙한 것을 사용할 수 있습니다. 이 예에서는 <a href="https://jwt.io/" target="_blank">JWT</a>로 인증하는 것을 상세하게 설명합니다.</p>
<p>아직 준비하지 않았다면 Snowflake와 이미 작동하고 있는 <a href="https://docs.snowflake.com/ko/user-guide/key-pair-auth.html#configuring-key-pair-authentication" target="_blank">키 쌍 인증</a>을 준비하십시오.</p>
<p>다음 명령을 사용하여 Snowflake 키 쌍과 성공적으로 연결할 수 있는지 확인하기 위해 테스트할 수 있습니다.</p>
<pre><code>$ snowsql -a &lt;account&gt; -u &lt;user&gt; --private-key-path &lt;path to private key&gt;
</code></pre>
<p>Negative : OAuth로 인증하고자 한다면 <a href="https://docs.snowflake.com/ko/developer-guide/sql-api/guide.html#using-oauth" target="_blank">OAuth</a>로 인증하는 것에 대한 Snowflake 설명서를 방문하십시오.</p>
<p>키 쌍 인증을 사용하여 Snowflake와 연결할 수 있음을 확인한 후 JWT 토큰을 생성해야 합니다.  이 JWT 토큰은 여러분의 키로 서명된 시간제한 토큰입니다. 또한 Snowflake는 여러분이 SQL API를 위해 이 토큰을 인증에 사용할 수 있도록 인가했음을 알게 됩니다.</p>
<pre><code>$ snowsql -a &lt;account&gt; -u &lt;user&gt; --private-key-path &lt;path to private key&gt; --generate-jwt
&lt;returns JWT token&gt;
</code></pre>
<p>생성된 JWT 토큰이 SQL API 사용에 사용되어야 합니다. 다음 헤더는 여러분의 애플리케이션 코드 내에서 전송하는 각 API 요청에 설정되어야 합니다.</p>
<ul>
<li><code>*jwt_token*</code>이 SnowSQL에서 생성된 JWT 토큰인 경우 <code>Authorization: Bearer *jwt_token*</code></li>
<li><code>X-Snowflake-Authorization-Token-Type: KEYPAIR_JWT</code></li>
</ul>
<p>전체적으로 여러분의 요청 쿼리와 헤더는 다음과 같은 형식입니다.</p>
<pre><code>POST /api/v2/statements?requestId=&lt;UUID&gt; HTTP/1.1
Authorization: Bearer &lt;jwt_token&gt;
Content-Type: application/json
Accept: application/json
User-Agent: myApplication/1.0
X-Snowflake-Authorization-Token-Type: KEYPAIR_JWT
</code></pre>
<p>인증과 고유한 요청 ID에 대해 알아보았으니 이제 실질적으로 SQL 문 실행을 위해 요청을 하는 방법을 알아보겠습니다.</p>


      </google-codelab-step>
    
      <google-codelab-step label="SQL 문 실행을 위해 요청 제출" duration="3">
        <p>실행을 위해 SQL 문을 제출하려면 <a href="https://docs.snowflake.com/ko/developer-guide/sql-api/reference.html#post-api-v2-statements" target="_blank">POST 요청을 /api/v2/statements/ endpoint</a>로 전송합니다.</p>
<pre><code>POST /api/v2/statements?requestId=&lt;UUID&gt; HTTP/1.1
Authorization: Bearer &lt;jwt_token&gt;
Content-Type: application/json
Accept: application/json
User-Agent: myApplication/1.0
X-Snowflake-Authorization-Token-Type: KEYPAIR_JWT

(request body)
</code></pre>
<p>요청 URL에서 쿼리 매개 변수를 다음과 같이 설정할 수 있습니다.</p>
<ul>
<li>비동기로 문 실행: <code>async=true</code></li>
</ul>
<p><a href="https://docs.snowflake.com/ko/developer-guide/sql-api/reference.html#body-of-the-post-request-to-api-v2-statements" target="_blank">요청 본문</a>을 위해 다음 필드를 설정합니다.</p>
<ul>
<li>실행하고 싶은 SQL 문에 <code>statement</code> 필드를 설정합니다.</li>
<li>웨어하우스, 데이터베이스, 스키마 및 역할을 사용에 지정하기 위해 <code>warehouse</code>, <code>database</code>, <code>schema</code> 및 <code>role</code> 필드를 설정합니다.</li>
</ul>
<p>Negative : 참고: 이러한 필드에 있는 값은 대/소문자를 구분합니다.</p>
<ul>
<li>문 실행에 시간제한을 설정하려면 <code>timeout</code> 필드를 최대 대기 시간(초)으로 설정합니다. <code>timeout</code> 필드가 설정되어 있지 않다면 <a href="https://docs.snowflake.com/ko/sql-reference/parameters.html#label-statement-timeout-in-seconds" target="_blank">STATEMENT_TIMEOUT_IN_SECONDS</a> 매개 변수에 의해 지정된 시간제한이 사용됩니다.</li>
</ul>
<pre><code>POST /api/v2/statements HTTP/1.1
Authorization: Bearer &lt;jwt_token&gt;
Content-Type: application/json
Accept: application/json
User-Agent: myApplication/1.0
X-Snowflake-Authorization-Token-Type: KEYPAIR_JWT

{
&#34;statement&#34;: &#34;select * from T&#34;,
&#34;timeout&#34;: 60,
&#34;database&#34;: &#34;&lt;your_database&gt;&#34;,
&#34;schema&#34;: &#34;&lt;your_schema&gt;&#34;,
&#34;warehouse&#34;: &#34;&lt;your_warehouse&gt;&#34;,
&#34;role&#34;: &#34;&lt;your_role&gt;&#34;
}
</code></pre>
<p>이 요청의 몇몇 특정 필드를 알아보겠습니다.</p>
<ul>
<li><code>statement</code> 필드는 실행할 SQL 문을 지정합니다.</li>
<li><code>timeout</code> 필드는 서버가 문 실행 시간을 60초까지 허용하도록 지정합니다.</li>
</ul>
<p>문이 성공적으로 실행되었다면 Snowflake는 HTTP 응답 코드 200을 반환하며 첫 결과를 <a href="https://docs.snowflake.com/ko/developer-guide/sql-api/reference.html#resultset" target="_blank">ResultSet</a> 오브젝트로 반환합니다. 바인드 변수를 포함하는 방법을 알아본 다음 상태를 확인하고 결과를 검색하는 방법을 알아보겠습니다.</p>
<p>이제 바인드 변수(<code>?</code> 자리 표시자)를 문에 포함하고 각 변수에 해당하는 Snowflake 데이터 형식과 값을 지정하는 오브젝트에 <code>bindings</code> 필드를 설정할 수 있는 방법을 알아보겠습니다.</p>


      </google-codelab-step>
    
      <google-codelab-step label="문에 바인드 변수 사용" duration="5">
        <p>바인드 변수(<code>?</code> 자리 표시자)를 문에 사용하고 싶다면 <code>bindings</code> 필드를 사용하여 삽입되어야 하는 값을 지정합니다.</p>
<p>이 필드를 각 바인드 변수의 <a href="https://docs.snowflake.com/ko/sql-reference/intro-summary-data-types.html" target="_blank">Snowflake 데이터 형식</a>과 값을 지정하는 JSON 오브젝트에 설정합니다.</p>
<pre><code>...
&#34;statement&#34;: &#34;select * from T where c1=?&#34;,
...
&#34;bindings&#34;: {
&#34;1&#34;: {
&#34;type&#34;: &#34;FIXED&#34;,
&#34;value&#34;: &#34;123&#34;
}
},
...
</code></pre>
<p>바인딩하는 값의 형식과 일치하는 바인딩 형식을 선택합니다. 예를 들어 값이 날짜(예: <code>2021-04-15</code>)를 나타내는 문자열이고 값을 DATE 열에 삽입하고 싶다면 <code>TEXT</code> 바인딩 형식을 사용합니다.</p>
<p>다음 테이블은 이 미리 보기 릴리스를 위해 다양한 <a href="https://docs.snowflake.com/ko/sql-reference/data-types.html" target="_blank">Snowflake 데이터 형식</a>을 바인딩하는 데 사용할 수 있는 <code>type</code> 필드의 값을 지정합니다.</p>
<ul>
<li>왼쪽에 있는 첫 열은 사용할 수 있는 바인딩 형식을 지정합니다.</li>
<li>나머지 열은 데이터 삽입을 계획하는 열의 Snowflake 데이터 형식을 지정합니다.</li>
<li>각 셀은 특정 Snowflake 데이터 형식의 열에 데이터를 삽입하기 위해 바인딩 형식과 함께 사용할 수 있는 값의 형식을 지정합니다.</li>
</ul>
<p>Negative : 바인딩 형식과 Snowflake 데이터 형식을 위한 셀이 비어 있다면 지정된 바인딩 형식을 사용하여 데이터를 해당 Snowflake 데이터 형식 열에 삽입할 수 없습니다.</p>
<p class="image-container"><img alt="바인딩 형식" src="img/82c6f92720df5bd1.png"></p>
<p>바인딩 전용 데이터 형식에 대한 추가 정보는 설명서의 <a href="https://docs.snowflake.com/ko/developer-guide/sql-api/reference.html#resultset" target="_blank">문에 바인드 변수 사용</a> 섹션을 확인하십시오.</p>
<p>값이 Snowflake에서 지원하지 않는 형식이라면 API는 오류를 반환합니다.</p>
<pre><code>{
code: &#34;100037&#34;,
message: &#34;&lt;bind type&gt; value &#39;&lt;value&gt;&#39; is not recognized&#34;,
sqlState: &#34;22018&#34;,
statementHandle: &#34;&lt;ID&gt;&#34;
}
</code></pre>
<p>바인드 변수 사용 여부에 관계없이 문 상태를 확인하는 것이 좋습니다. 다음 단계에서 이를 살펴보겠습니다.</p>


      </google-codelab-step>
    
      <google-codelab-step label="문 실행 상태 확인" duration="1">
        <p>실행을 위해 SQL 문을 제출할 때 문 실행이 아직 완료되지 않았거나 비동기 쿼리를 제출했을 경우 Snowflake는 202 응답 코드를 반환합니다.</p>
<p>응답 본문에서 Snowflake는 <a href="https://docs.snowflake.com/ko/developer-guide/sql-api/reference.html#querystatus" target="_blank">QueryStatus</a> 오브젝트를 포함합니다. 이 오브젝트의 <code>statementStatusUrl</code> 필드는 실행 상태를 확인하기 위해 사용할 수 있는 <a href="https://docs.snowflake.com/ko/developer-guide/sql-api/reference.html#get-api-v2-statements-statementhandle" target="_blank">/api/v2/statements/ endpoint</a> URL을 지정합니다.</p>
<pre><code>{
&#34;code&#34;: &#34;090001&#34;,
&#34;sqlState&#34;: &#34;00000&#34;,
&#34;message&#34;: &#34;successfully executed&#34;,
&#34;statementHandle&#34;: &#34;e4ce975e-f7ff-4b5e-b15e-bf25f59371ae&#34;,
&#34;statementStatusUrl&#34;: &#34;/api/v2/statements/e4ce975e-f7ff-4b5e-b15e-bf25f59371ae&#34;
}
</code></pre>
<p>위 URL에서 묘사하는 것처럼 문 상태를 확인하고 문 실행을 취소하는 요청에서는 사용할 문을 식별하기 위해 문 핸들(문을 위한 고유한 식별자)을 경로 매개 변수로 지정합니다.</p>
<p><code>QueryStatus</code> 오브젝트 또한 문 핸들을 <code>statementHandle</code> 필드에서 별도의 값으로 제공합니다.</p>
<p>문 실행 상태를 확인하려면 다음 URL을 사용하여 GET 요청을 전송합니다.</p>
<pre><code>GET /api/v2/statements/{statementHandle}
</code></pre>
<p>예를 들어 다음 요청은 <code>e4ce975e-f7ff-4b5e-b15e-bf25f59371ae</code> 핸들로 문 실행 상태를 확인합니다.</p>
<pre><code>GET /api/v2/statements/e4ce975e-f7ff-4b5e-b15e-bf25f59371ae HTTP/1.1
Authorization: Bearer &lt;jwt_token&gt;
Content-Type: application/json
Accept: application/json
User-Agent: myApplication/1.0
X-Snowflake-Authorization-Token-Type: KEYPAIR_JWT
</code></pre>
<p>문이 성공적인 실행되었다면 Snowflake는 HTTP 응답 코드 200을 반환하며 첫 결과를 <a href="https://docs.snowflake.com/ko/developer-guide/sql-api/reference.html#resultset" target="_blank">ResultSet</a> 오브젝트로 반환합니다. 그러나 문 실행 시 오류가 발생했다면 Snowflake는 HTTP 응답 코드 422와 더불어 <a href="https://docs.snowflake.com/ko/developer-guide/sql-api/reference.html#queryfailurestatus" target="_blank">QueryFailureStatus</a> 오브젝트를 반환합니다.</p>
<p>문이 성공적으로 실행된 다음 결과를 검색할 수 있습니다. 이는 다음 단계에서 자세히 설명합니다.</p>
<h2 is-upgraded>SQL 문 실행 취소</h2>
<p>문 실행을 취소하려면 POST 요청을 <a href="https://docs.snowflake.com/ko/developer-guide/sql-api/guide.html#cancelling-the-execution-of-a-sql-statement" target="_blank">cancel endpoint</a>로 전송합니다.</p>
<pre><code>POST /api/v2/statements/{statementHandle}/cancel
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="결과 검색" duration="1">
        <p><a href="https://docs.snowflake.com/ko/developer-guide/sql-api/guide.html#label-sql-api-executing-multiple-statements" target="_blank">실행을 위해 SQL 문을 제출</a>하거나 <a href="https://docs.snowflake.com/ko/developer-guide/sql-api/guide.html#checking-the-status-of-the-statement-execution-and-retrieving-the-data" target="_blank">문 실행 상태를 확인</a>한다면, 문이 성공적으로 실행되었을 경우 Snowflake는 <a href="https://docs.snowflake.com/ko/developer-guide/sql-api/guide.html#checking-the-status-of-the-statement-execution-and-retrieving-the-data" target="_blank">ResultSet</a> 오브젝트를 응답 본문에서 반환합니다.</p>
<p>다음은 쿼리를 대상으로 반환된 <code>ResultSet</code> 오브젝트의 예입니다. 이는 간결성을 위해 잘렸습니다.</p>
<pre><code>{
  &#34;code&#34; : &#34;090001&#34;,
  &#34;statementStatusUrl&#34; : &#34;/api/v2/statements/01a288b9-0603-af68-0000-328502422e7e?requestId=f8ccd534-7cd5-4c06-b673-f25361e96d7f&#34;,
  &#34;requestId&#34; : &#34;f8ccd534-7cd5-4c06-b673-f25361e96d7f&#34;,
  &#34;sqlState&#34; : &#34;00000&#34;,
  &#34;statementHandle&#34; : &#34;01a288b9-0603-af68-0000-328502422e7e&#34;,
  &#34;message&#34; : &#34;Statement executed successfully.&#34;,
  &#34;createdOn&#34; : 1645742998434,
  &#34;resultSetMetaData&#34; : {
    &#34;rowType&#34; : [ {
      &#34;name&#34; : &#34;HIGH_NDV_COLUMN&#34;,
      &#34;database&#34; : &#34;&#34;,
      &#34;schema&#34; : &#34;&#34;,
      &#34;table&#34; : &#34;&#34;,
      &#34;type&#34; : &#34;fixed&#34;,
      &#34;scale&#34; : 0,
      &#34;precision&#34; : 19,
      &#34;byteLength&#34; : null,
      &#34;nullable&#34; : false,
      &#34;collation&#34; : null,
      &#34;length&#34; : null
    }, {
      &#34;name&#34; : &#34;LOW_NDV_COLUMN&#34;,
      &#34;database&#34; : &#34;&#34;,
      &#34;schema&#34; : &#34;&#34;,
      &#34;table&#34; : &#34;&#34;,
      &#34;type&#34; : &#34;fixed&#34;,
      &#34;scale&#34; : 0,
      &#34;precision&#34; : 2,
      &#34;byteLength&#34; : null,
      &#34;nullable&#34; : false,
      &#34;collation&#34; : null,
      &#34;length&#34; : null
    }, {
      &#34;name&#34; : &#34;CONSTANT_COLUM&#34;,
      &#34;database&#34; : &#34;&#34;,
      &#34;schema&#34; : &#34;&#34;,
      &#34;table&#34; : &#34;&#34;,
      &#34;type&#34; : &#34;fixed&#34;,
      &#34;scale&#34; : 0,
      &#34;precision&#34; : 1,
      &#34;byteLength&#34; : null,
      &#34;nullable&#34; : false,
      &#34;collation&#34; : null,
      &#34;length&#34; : null
    } ],
    &#34;numRows&#34; : 100000000,
    &#34;format&#34; : &#34;jsonv2&#34;,
    &#34;partitionInfo&#34; : [ {
      &#34;rowCount&#34; : 8192,
      &#34;uncompressedSize&#34; : 152879,
      &#34;compressedSize&#34; : 22412
    }, {
      &#34;rowCount&#34; : 53248,
      &#34;uncompressedSize&#34; : 1048161,
      &#34;compressedSize&#34; : 151251
    }, {
      &#34;rowCount&#34; : 86016,
      &#34;uncompressedSize&#34; : 1720329,
      &#34;compressedSize&#34; : 249447
    }, {
</code></pre>
<p><code>partitionInfo</code> 오브젝트의 <code>ARRAY</code>가 있다는 것을 확인하십시오.  이러한 파티션 오브젝트는 검색에 사용 가능한 파티션에 대한 rowCount 및 사이즈와 같은 일부 정보를 제공합니다.  API는 첫 파티션의 JSON에서 데이터 인라인을 반환합니다. 또는 응답을 포함한 <code>0</code> 파티션을 반환합니다. 추후 섹션에서는 후속 파티션을 검색하는 방법을 알아보겠습니다.</p>
<h2 is-upgraded>결과에 대한 메타데이터 가져오기</h2>
<p>쿼리에서 반환된 데이터 형식 및 데이터 이름에 대한 추가 메타데이터를 제공하는 <code>rowType</code> 응답에도 포함되어 있습니다.  이 메타데이터는 초기 응답에만 포함되며 후속 파티션을 검색할 때 반환되는 메타데이터는 없습니다.</p>
<p>응답에서 반환된 <code>ResultSet</code> 오브젝트에서 <code>resultSetMetaData</code> 필드는 결과 세트(예: 결과 형식 등)를 설명하는 <a href="https://docs.snowflake.com/ko/developer-guide/sql-api/guide.html#getting-metadata-about-the-results" target="_blank"><code>ResultSet_resultSetMetaData</code></a> 오브젝트를 포함합니다.</p>
<p>이 오브젝트에서 <code>rowType</code> 필드는 <a href="https://docs.snowflake.com/ko/developer-guide/sql-api/reference.html#label-sql-api-reference-resultset-resultsetmetadata-rowtype" target="_blank">ResultSet_resultSetMetaData_rowType</a> 오브젝트의 배열을 포함합니다. 각 오브젝트는 결과에서 열을 설명합니다. <code>type</code> 필드는 열의 Snowflake 데이터 형식을 지정합니다.</p>
<pre><code>{
&#34;resultSetMetaData&#34;: {
&#34;rowType&#34;: [
{
&#34;name&#34;:&#34;ROWNUM&#34;,
&#34;type&#34;:&#34;FIXED&#34;,
&#34;length&#34;:0,
&#34;precision&#34;:38,
&#34;scale&#34;:0,
&#34;nullable&#34;:false
}, {
&#34;name&#34;:&#34;ACCOUNT_NAME&#34;,
&#34;type&#34;:&#34;TEXT&#34;,
&#34;length&#34;:1024,
&#34;precision&#34;:0,
&#34;scale&#34;:0,
&#34;nullable&#34;:false
}, {
&#34;name&#34;:&#34;ADDRESS&#34;,
&#34;type&#34;:&#34;TEXT&#34;,
&#34;length&#34;:16777216,
&#34;precision&#34;:0,
&#34;scale&#34;:0,
&#34;nullable&#34;:true
}, {
&#34;name&#34;:&#34;ZIP&#34;,
&#34;type&#34;:&#34;TEXT&#34;,
&#34;length&#34;:100,
&#34;precision&#34;:0,
&#34;scale&#34;:0,
&#34;nullable&#34;:true
}, {
&#34;name&#34;:&#34;CREATED_ON&#34;,
&#34;type&#34;:&#34;TIMESTAMP_NTZ&#34;,
&#34;length&#34;:0,
&#34;precision&#34;:0,
&#34;scale&#34;:3,
&#34;nullable&#34;:false
}
]
},
}
</code></pre>
<h2 is-upgraded>결과 파티션 검색</h2>
<p>파티션은 <code>/api/v2/statements/<handle>?partition=<partition_number></code> 엔드포인트에서 <code>partition=n</code> 쿼리 매개 변수를 사용하여 <a href="https://docs.snowflake.com/ko/developer-guide/sql-api/guide.html#retrieving-additional-partitions" target="_blank">검색</a>됩니다.  이는 SQL API 호출에서 가져온 결과를 반복하거나 동시에 검색하기 위해 사용될 수 있습니다.</p>
<pre><code>GET /api/v2/statements/e4ce975e-f7ff-4b5e-b15e-bf25f59371ae?partition=1 HTTP/1.1
Authorization: Bearer &lt;jwt_token&gt;
Content-Type: application/json
Accept: application/json
User-Agent: myApplication/1.0
X-Snowflake-Authorization-Token-Type: KEYPAIR_JWT
</code></pre>
<p><code>partition=1</code>을 포함한 위 쿼리 호출은 아래 데이터만 반환합니다.  <code>data</code> 오브젝트에는 결과에 대한 어떠한 추가 메타데이터도 포함되지 않습니다.  압축을 풀어야 하는 GZIP 형식의 데이터만 반환됩니다.</p>
<pre><code>{&#34;data&#34;: [
[&#34;32768&#34;,&#34;3&#34;,&#34;5&#34;],
[&#34;32772&#34;,&#34;4&#34;,&#34;5&#34;],
[&#34;32776&#34;,&#34;3&#34;,&#34;5&#34;],
[&#34;32780&#34;,&#34;3&#34;,&#34;5&#34;],
[&#34;32784&#34;,&#34;2&#34;,&#34;5&#34;],
....
]}
</code></pre>
<p>배열 내 각 배열에는 행을 위한 데이터가 포함되어 있습니다.</p>
<ul>
<li>각 배열의 첫 요소는 0부터 시작하는 후속 ID를 포함하는 JSON 문자열입니다.</li>
<li>각 배열의 나머지 요소는 행에 있는 데이터를 나타냅니다.</li>
</ul>
<p>결과 세트에 있는 데이터는 JSON v1.0로 인코딩되어 있습니다. 이는 열의 Snowflake 데이터 형식에 관계없이 모든 데이터가 문자열로 표현됨을 의미합니다.</p>
<p>예를 들어 <code>NUMBER</code> 열에서 <code>1.0</code> 값이 <code>" 1.0"</code> 문자열로 반환됩니다. 또 다른 예는 타임스탬프가 에포크 이후로 나노초 숫자로 반환되는 것입니다. 예를 들어 2021년 1월 28일 목요일 10:09:37.123456789 PM의 타임스탬프는 <code>"1611871777123456789"</code>로 반환됩니다.</p>
<p>문자열을 적절한 데이터 형식으로 변환하는 것은 여러분의 책임입니다.</p>
<h2 is-upgraded>파티션 반복 및 검색을 위한 유용한 URL</h2>
<p>여러분의 결과에 많은 수의 파티션이 포함되어 있을 수 있기에 Snowflake SQL API는 특수 헤더(<code>Link</code>)를 제공합니다. 이는 클라이언트가 이러한 결과를 트래버스하고 검색하는 데 도움을 줍니다.</p>
<p>결과의 다음 파티션 또는 기타 파티션을 가져오려면 HTTP 응답의 <a href="https://docs.snowflake.com/ko/developer-guide/sql-api/reference.html#response-headers-for-all-operations" target="_blank">Link 헤더</a>에서 제공된 URL을 사용합니다. <code>Link</code> 헤더는 결과의 첫 번째, 다음, 이전 및 마지막 파티션을 검색하기 위한 URL을 지정합니다.</p>
<pre><code>HTTP/1.1 200 OK
Link: &lt;/api/v2/statements/01a288b9-0603-af68-0000-328502422e7e?requestId=918e2211-d1d6-4c53-bec3-457d047651f7&amp;partition=0&gt;; rel=&#34;first&#34;
,&lt;/api/v2/statements/01a288b9-0603-af68-0000-328502422e7e?requestId=51ad0c0a-e514-4d8a-9cf2-cf537d439e39&amp;partition=1&gt;; rel=&#34;next&#34;
,&lt;/api/v2/statements/01a288b9-0603-af68-0000-328502422e7e?requestId=c6a17bb3-7593-489d-bbac-5e3b268bc6da&amp;partition=47&gt;; rel=&#34;last&#34;
...
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="종료 및 다음 단계" duration="1">
        <p>이 자습서는 Snowflake SQL API에 대한 실습 소개로 설계되었습니다. API로 수행할 수 있는 작업을 보려면 <a href="https://docs.snowflake.com/ko/developer-guide/sql-api/reference.html" target="_blank">Snowflake SQL API 참조</a>를 확인하십시오.</p>
<p>Snowflake 무료 평가판을 사용하여 이 랩을 완료했다면 Snowflake로 수행할 수 있는 작업을 계속해서 탐색하는 것을 권장합니다. Snowflake는 다음을 통해 여러 방법으로 도움을 줄 수 있습니다.</p>
<ul>
<li>Snowflake를 통해 여러분의 데이터를 분석하는 데 도움을 받기 위해 평가판/무료 ETL 및 BI 도구에 대한 액세스를 얻으려면 UI 맨 위에 있는 ‘Partner Connect&#39; 아이콘을 클릭하십시오</li>
<li>‘<a href="https://www.snowflake.com/test-driving-snowflake-the-definitive-guide-to-maximizing-your-free-trial/" target="_blank">무료 평가판 극대화를 위한 가이드</a>&#39; 문서를 확인하십시오</li>
<li>Snowflake 가상 또는 현장 <a href="https://www.snowflake.com/about/webinars/" target="_blank">이벤트</a>에 참석하여 Snowflake의 기능 및 고객에 관해 자세히 알아보십시오.</li>
<li>더 자세한 내용은 <a href="https://www.snowflake.com/free-trial-contact-sales/" target="_blank">영업 팀</a>에 문의하시기 바랍니다</li>
</ul>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/native-shim.js"></script>
  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/custom-elements.min.js"></script>
  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/prettify.js"></script>
  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>
  <script type="text/javascript">
    window.heap=window.heap||[],heap.load=function(e,t){window.heap.appid=e,window.heap.config=t=t||{};var r=t.forceSSL||"https:"===document.location.protocol,a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src=(r?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+e+".js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(a,n);for(var o=function(e){return function(){heap.push([e].concat(Array.prototype.slice.call(arguments,0)))}},p=["addEventProperties","addUserProperties","clearEventProperties","identify","removeEventProperty","setEventProperties","track","unsetEventProperty"],c=0;c<p.length;c++)heap[p[c]]=o(p[c])};
    heap.load("2025084205");
  </script>
</body>
</html>
