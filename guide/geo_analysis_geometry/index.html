
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Geospatial Analysis using Geometry Data Type</title>

  
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-5Q8R2G');</script>
  

  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-08H27EW14N"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-08H27EW14N');
</script>

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://quickstarts.snowflake.com/elements/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5Q8R2G"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  
  <google-codelab-analytics gaid="UA-41491190-9"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="geo_analysis_geometry"
                  title="Geospatial Analysis using Geometry Data Type"
                  environment="web"
                  feedback-link="https://github.com/Snowflake-Labs/sfguides/issues">
    
      <google-codelab-step label="Overview" duration="10">
        <p>Geospatial query capabilities in Snowflake are built upon a combination of data types and specialized query functions that can be used to parse, construct, and run calculations over geospatial objects. This guide will introduce you to the <code>GEOMETRY</code> data type, help you understand geospatial formats supported by Snowflake and walk you through the use of a variety of functions on sample geospatial data sets.</p>
<h2 is-upgraded>Prerequisites</h2>
<ul>
<li>Quick Video <a href="https://www.youtube.com/watch?v=fEtoYweBNQ4&ab_channel=SnowflakeInc." target="_blank">Introduction to Snowflake</a></li>
<li>Snowflake <a href="https://www.youtube.com/watch?v=us6MChC8T9Y&ab_channel=SnowflakeInc." target="_blank">Data Loading Basics</a> Video</li>
</ul>
<h2 class="checklist" is-upgraded>What You&#39;ll Learn</h2>
<ul class="checklist">
<li>How to acquire geospatial data from the Snowflake Marketplace</li>
<li>How to load geospatial data from internal and external Stages</li>
<li>How to interpret the <code>GEOMETRY</code> data type and how it differs from the <code>GEOGRAPHY</code></li>
<li>How to understand the different formats that <code>GEOMETRY</code> can be expressed in</li>
<li>How to do spatial analysis using the GEOMETRY and GEOGRAPHY data types</li>
</ul>
<h2 is-upgraded>What You&#39;ll Need</h2>
<ul>
<li>A supported Snowflake <a href="https://docs.snowflake.com/en/user-guide/setup.html" target="_blank">Browser</a></li>
<li>Sign-up for a <a href="https://signup.snowflake.com/" target="_blank">Snowflake Trial</a>  OR have access to an existing Snowflake account with the <code>ACCOUNTADMIN</code> role or the <code>IMPORT SHARE</code> privilege. Select the Enterprise edition, AWS as a cloud provider and US East (Northern Virginia) or EU (Frankfurt) as a region.</li>
</ul>
<h2 is-upgraded>What You&#39;ll Build</h2>
<p>A sample use case that involves energy grids and LTE cell towers in Netherlands You will answer the following questions:</p>
<ul>
<li>What the length of all energy grids in each municipality in Netherlands</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Setup your Account" duration="5">
        <aside class="warning"><p> If you are trying this Quickstart before June 20th 2023, please make sure that you enabled the following Private Preview features for your Trial Snowflake Account:</p>
<ul>
<li><a href="https://docs.snowflake.com/en/LIMITEDACCESS/udf-python-file-handler" target="_blank">Dyamic File Access</a></li>
<li><a href="https://docs.snowflake.com/LIMITEDACCESS/st_transform" target="_blank">ST_TRANSFORM</a></li>
</ul>
</aside>
<p><a href="https://app.snowflake.com/" target="_blank">app.snowflake.com</a></p>
<p>If this is the first time you are logging into the Snowflake UI, you will be prompted to enter your account name or account URL that you were given when you acquired a trial. The account URL contains your <a href="https://docs.snowflake.com/en/user-guide/connecting.html#your-snowflake-account-name" target="_blank">account name</a> and potentially the region. You can find your account URL in the email that was sent to you after you signed up for the trial.</p>
<p>Click <code>Sign-in</code> and you will be prompted for your user name and password.</p>
<aside class="special"><p> If this is not the first time you are logging into the Snowflake UI, you should see a &#34;Select an account to sign into&#34; prompt and a button for your account name listed below it. Click the account you wish to access and you will be prompted for your user name and password (or another authentication mechanism).</p>
</aside>
<h2 is-upgraded>Increase Your Account Permission</h2>
<p>The Snowflake web interface has a lot to offer, but for now, switch your current role from the default <code>SYSADMIN</code> to <code>ACCOUNTADMIN</code>. This increase in permissions will allow you to create shared databases from Snowflake Marketplace listings.</p>
<aside class="special"><p> If you don&#39;t have the <code>ACCOUNTADMIN</code> role, switch to a role with <code>IMPORT SHARE</code> privileges instead.</p>
</aside>
<p class="image-container"><img style="width: 500.00px" src="img/b9575209bfee61ca.png"></p>
<h2 is-upgraded>Create a Virtual Warehouse</h2>
<p>You will need to create a Virtual Warehouse to run queries.</p>
<ul>
<li>Navigate to the <code>Admin > Warehouses</code> screen using the menu on the left side of the window</li>
<li>Click the big blue <code>+ Warehouse</code> button in the upper right of the window</li>
<li>Create an Large Warehouse as shown in the screen below</li>
</ul>
<p class="image-container"><img style="width: 500.00px" src="img/1e9fb04bc904a0d2.png"></p>
<p>Be sure to change the <code>Suspend After (min)</code> field to 5 min to avoid wasting compute credits.</p>
<h2 is-upgraded>Acknowledge the Snowflake Third Party Terms</h2>
<p>In order to use the packages provided by Anaconda inside Snowflake, you must acknowledge the Snowflake Third Party Terms.</p>
<ul>
<li>Select Admin » Billing &amp; Terms.</li>
<li>In the Anaconda section, select Enable.</li>
<li>In the Anaconda Packages dialog, click the link to review the Snowflake Third Party Terms page.</li>
<li>If you agree to the terms, select <code>Acknowledge & Continue</code>.</li>
</ul>
<h2 is-upgraded>Connect Snowflake and Carto</h2>
<p>Let&#39;s connect your Snowflake to CARTO so you can run and visualize the queries in the following exercises of this workshop.</p>
<p>Access the CARTO Workspace: <a href="http://app.carto.com/" target="_blank">app.carto.com</a></p>
<p>Go to the Connections section in the Workspace, where you can find the list of all your current connections.</p>
<p class="image-container"><img style="width: 700.00px" src="img/db82211120d23db7.png"></p>
<p>To add a new connection, click on <code>New connection</code> and follow these steps:</p>
<ol type="1">
<li>Select Snowflake.</li>
<li>Click the <code>Setup connection</code> button.</li>
<li>Enter the connection parameters and credentials.</li>
</ol>
<p>These are the parameters you need to provide:</p>
<ul>
<li><strong>Name</strong> for your connection: You can register different connections with the Snowflake connector. You can use the name to identify the connections.</li>
<li><strong>Username</strong>: Name of the user account.</li>
<li><strong>Password</strong>: Password for the user account.</li>
<li><strong>Account</strong>: Hostname for your account . One way to get it is to check the Snowflake activation email which contains the account_name within the URL ( &lt;account_name&gt;.snowflakecomputing.com ). Just enter what&#39;s on the account_name, i.e ok36557.us-east-2.aws</li>
<li><strong>Warehouse (optional)</strong>: Default warehouse that will run your queries. Use MY_WH.</li>
</ul>
<aside class="warning"><p> Use MY_WH or the name of the data warehouse you created in the previous step otherwise some queries will fail because CARTO won&#39;t know which warehouse to run them against.</p>
</aside>
<ul>
<li><strong>Database (optional)</strong>. Default database to run your queries. Use GEOLAB.</li>
<li><strong>Role (optional)</strong>. Default Role to run your queries. Use ACCOUNTADMIN.</li>
</ul>
<p class="image-container"><img style="width: 700.00px" src="img/dabb63ec691a4abc.png"></p>
<p>Once you have entered the parameters, you can click the Connect button. CARTO will try to connect to your Snowflake account. If everything is OK, your new connection will be registered.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Acquire Marketplace Data and Analytics Toolbox" duration="5">
        <p>The first step in the guide is to acquire geospatial data sets that you can freely use to explore the basics of Snowflake&#39;s geospatial functionality.  The best place to acquire this data is the Snowflake Marketplace!</p>
<ul>
<li>Navigate to the <code>Marketplace</code> screen using the menu on the left side of the window</li>
<li>Search for <code>OpenCelliD</code> in the search bar</li>
<li>Find and click the <code>OpenCelliD - Open Database of Cell Towers</code> tile</li>
</ul>
<p class="image-container"><img style="width: 700.00px" src="img/733037ef599ccab.png"></p>
<ul>
<li>Once in the listing, click the big blue <code>Get</code> button</li>
</ul>
<aside class="warning"><p> On the <code>Get</code> screen, you may be prompted to complete your <code>user profile</code> if you have not done so before. Click the link as shown in the screenshot below. Enter your name and email address into the profile screen and click the blue <code>Save</code> button. You will be returned to the <code>Get</code> screen.</p>
</aside>
<p class="image-container"><img style="width: 500.00px" src="img/266bfe4f1f5ba1a3.png"></p>
<ul>
<li>On the <code>Get Data</code> screen, change the name of the database from the default to <code>OPENCELLID</code>, as this name is shorter, and all future instructions will assume this name for the database.</li>
</ul>
<p class="image-container"><img style="width: 500.00px" src="img/86244de138cc244e.png"></p>
<p>Congratulations! You have just created a shared database from a listing on the Snowflake Marketplace.</p>
<p>Similarly to the above dataset, search and get the <code>Netherlands Open Map Data - Sonra</code> dataset from the Marketplace and rename it to <code>osm_nl</code>.</p>
<p class="image-container"><img style="width: 500.00px" src="img/f46c61d31c1209e2.png"></p>
<h2 is-upgraded>Install CARTO Analytics Toolbox from the Snowflake Marketplace</h2>
<p>Now you can acquire CARTO&#39;s Analytics Toolbox from the Snowflake Marketplace. This will share UDFs (User defined functions) to your account that will allow you to perform even more geospatial analytics.</p>
<ul>
<li>Similar to how you did with the data in the previous steps, navigate to the <code>Marketplace</code> screen using the menu on the left side of the window</li>
<li>Search for <code>CARTO</code> in the search bar</li>
</ul>
<p class="image-container"><img style="width: 700.00px" src="img/1ea45be8fefae346.png"></p>
<ul>
<li>Find and click the <code>Analytics Toolbox</code>  tile</li>
</ul>
<p class="image-container"><img style="width: 700.00px" src="img/8989fbb85e5b9106.png"></p>
<ul>
<li>Click on big blue <code>Get</code>  button</li>
<li>In the options, name the database <code>CARTO</code> and optionally add more roles that can access the database</li>
</ul>
<p class="image-container"><img style="width: 500.00px" src="img/fb30ccaee6fed7f6.png"></p>
<ul>
<li>Click on <code>Get</code> and then <code>Done</code>.</li>
</ul>
<p>Congratulations! Now you have data and the analytics toolbox!</p>


      </google-codelab-step>
    
      <google-codelab-step label="Load Data from External Storage" duration="5">
        <p>Now that you understand how to get data from Marketplace, let&#39;s try another way of getting data, namely, getting it from the external S3 storage. While we loadinging data we will learn formats supported by geospatial data types, use Python UDFs constructors.</p>
<p>In this step, we&#39;re going to use Snowflake&#39;s <a href="https://docs.snowflake.com/en/user-guide/data-load-s3-create-stage#create-an-external-stage-using-snowsight" target="_blank">Create an External Stage Using Snowsight</a> feature to create a table using a dataset with energy grids stored in the external Stage.</p>
<p>Navigate to the query editor by clicking on  <code>Worksheets</code>  on the top left navigation bar and choose your warehouse.</p>
<ul>
<li>Click the + Worksheet button in the upper right of your browser window. This will open a new window.</li>
<li>In the new Window, make sure <code>ACCOUNTADMIN</code> and <code>MY_WH</code> (or whatever your warehouse is named) are selected in the upper right of your browser window.</li>
</ul>
<p class="image-container"><img style="width: 700.00px" src="img/2ab2115d49c67d4b.png"></p>
<p>Create a new database and schema where we will store datasets in the Geography data type. Copy &amp; paste the SQL below into your worksheet editor, put your cursor somewhere in the text of the query you want to run (usually the beginning or end), and either click the blue &#34;Play&#34; button in the upper right of your browser window, or press <code>CTRL+Enter</code> or <code>CMD+Enter</code> (Windows or Mac) to run the query.</p>
<pre><code>CREATE OR REPLACE DATABASE GEOLAB;
CREATE OR REPLACE schema GEOLAB.GEOMETRY;
// Set the working database schema
USE SCHEMA GEOLAB.GEOMETRY;
</code></pre>
<p>Now, you will create a stage using an external S3 bucket. In the navigation menu, select Data &gt; Databases. Select <code>GEOLAB.GEOMETRY</code>, and click Create &gt; Stage &gt; Amazon S3.</p>
<p class="image-container"><img src="img/6d4714d860b28552.png"></p>
<p>In the new Window, use the name geostage, and put the following link to the external stage in the URL field: <em>s3://sfquickstarts/vhol_spatial_analysis_geometry_geography/.</em> Then click Create button.</p>
<p class="image-container"><img style="width: 500.00px" src="img/a918369760896542.png"></p>
<p>Now you will create a new table using the file from that stage. Run the following queries to create a new file format and a new table using the dataset stored in the Stage:</p>
<pre><code>// Set the working database schema
CREATE OR REPLACE FILE format mycsv TYPE = CSV SKIP_HEADER = 1 FIELD_OPTIONALLY_ENCLOSED_BY = &#39;&#34;&#39;;
CREATE OR REPLACE TABLE GEOLAB.GEOMETRY.nl_cables_stations AS SELECT to_geometry($1) as geometry, $2 as id, $3 as type FROM @geostage/nl_stations_cables.csv (file_format =&gt; &#39;mycsv&#39;);
</code></pre>
<p>Look at the description of the table you just created by running the following queries:</p>
<pre><code>// Set the working database schema
USE SCHEMA geolab.geometry;
DESC TABLE nl_cables_stations;
</code></pre>
<p>The <a href="https://docs.snowflake.com/en/sql-reference/sql/use-schema.html" target="_blank">use schema</a> command sets the active database.schema for your future queries so you do not have to fully qualify your objects. The <a href="https://docs.snowflake.com/en/sql-reference/sql/desc.html" target="_blank">desc or describe</a> command shows you the definition of the view, including the columns, their data type, and other relevant details. Notice the <code>geometry</code> column is defined as <code>GEOMETRY</code> type.</p>
<p>Snowflake supports 3 primary geospatial formats and 2 additional variations on those formats. They are:</p>
<ul>
<li><strong>GeoJSON</strong>: a JSON-based standard for representing geospatial data</li>
<li><strong>WKT &amp; EWKT</strong>: a &#34;Well Known Text&#34; string format for representing geospatial data and the &#34;Extended&#34; variation of that format</li>
<li><strong>WKB &amp; EWKB:</strong> a &#34;Well Known Binary&#34; format for representing geospatial data in binary and the &#34;Extended&#34; variation of that format</li>
</ul>
<p>These formats are supported for ingestion (files containing those formats can be loaded into a <code>GEOMETRY</code> typed column), query result display, and data unloading to new files. You don&#39;t need to worry about how Snowflake stores the data under the covers but rather how the data is displayed to you or unloaded to files through the value of session variables called <code>GEOMETRY_OUTPUT_FORMAT</code>.</p>
<p>Run the queries below to make sure the current format is GeoJSON.</p>
<pre><code>// Set the output format to GeoJSON
ALTER SESSION SET geometry_output_format = &#39;GEOJSON&#39;;
</code></pre>
<p>The <a href="https://docs.snowflake.com/en/sql-reference/sql/alter-session.html" target="_blank">alter session</a> command lets you set a parameter for your current user session, which in this case is  <code>GEOMETRY_OUTPUT_FORMAT</code>. The default value for those parameters is <code>'GEOJSON'</code>, so normally you wouldn&#39;t have to run this command if you want that format, but this guide wants to be certain the next queries are run with the <code>'GEOJSON'</code> output.</p>
<p>Now run the following query against the <code>nl_cables_stations</code> table to see energy grids in Netherlands.</p>
<pre><code>SELECT geometry
FROM nl_cables_stations
LIMIT 10;
</code></pre>
<p>In the result set, notice the <code>geometry</code> column and how it displays a JSON representation of spatial objects. It should look similar to this:</p>
<pre><code>{&#34;coordinates&#34;: [[[1.852040750000000e+05, 3.410349640000000e+05], [1.852044840000000e+05,3.410359860000000e+05]], [[1.852390240000000e+05,3.411219340000000e+05], ... ,[1.852800600000000e+05,3.412219960000000e+05]]   ], &#34;type&#34;: &#34;MultiLineString&#34; }
</code></pre>
<p>Unlike <code>GEOGRAPHY</code>, which treats all points as longitude and latitude on a spherical earth, <code>GEOMETRY</code> considers the Earth as a flat surface. That is why in <code>GEOMETRY</code> we use the planar coordinate system, where coordinates are similar to X and Y coordinates that you used in the geometry course in your school. More information about Snowflake&#39;s specification can be found <a href="https://docs.snowflake.com/en/sql-reference/data-types-geospatial.html" target="_blank">here</a>. In this example it uses the scientific notation and the numbers are much larger than latitude and longitude boundaries [-180; 180].</p>
<p class="image-container"><img style="width: 700.00px" src="img/d269aa575b1cbcab.png"></p>
<p>Now look at the same query but in a different format. Run the following query:</p>
<pre><code>// Set the output format to EWKT
ALTER SESSION SET geometry_output_format = &#39;EWKT&#39;;
</code></pre>
<p>Run the previous <code>SELECT</code> query again and when done, examine the output in the <code>geometry</code> column.</p>
<pre><code>SELECT geometry
FROM nl_cables_stations
LIMIT 10;
</code></pre>
<p>EWKT looks different than GeoJSON, and is arguably more readable. Here you can more clearly see the <a href="https://docs.snowflake.com/en/sql-reference/data-types-geospatial.html#geospatial-object-types" target="_blank">geospatial object types</a>, which are represented below in the example output:</p>
<pre><code>SRID=28992;MULTILINESTRING((185204.075 341034.964,185204.484 341035.986), ... ,(185276.402 341212.688,185279.319 341220.196,185280.06 341221.996))
</code></pre>
<p>EWKT also shows spatial reference identifier and in our example, we have a dataset in <a href="https://epsg.io/28992" target="_blank">Amersfoort / RD New</a> spatial reference system, that is why displayed SRID is 28992.</p>
<p>Lastly, look at the WKB output. Run the following query:</p>
<pre><code>// Set the output format to WKB
ALTER SESSION SET geometry_output_format = &#39;WKB&#39;;
</code></pre>
<p>Run the query again, and click on a cell in the <code>geometry</code> column.</p>
<pre><code>SELECT geometry 
FROM nl_cables_stations 
LIMIT 10;
</code></pre>
<p>Notice how WKB is incomprehensible to a human reader. However, this format is handy in data loading/unloading, as it can be more compact than WKB or GeoJSON.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Load Data from Internal Storage" duration="10">
        <p>Now that you have a basic understanding of how the <code>GEOMETRY</code> data type works and what a geospatial representation of data looks like in various output formats, it&#39;s time to walkthrough a scenario that requires you to use constructors to load data.  We will do it while trying one more way of getting data, namely, from the Shapefile file stored in the internal stage.</p>
<p>First download <a href="https://sfquickstarts.s3.us-west-1.amazonaws.com/vhol_spatial_analysis_geometry_geography/nl_areas.zip" target="_blank">this</a> Shapefile which contains boundaries of administrative areas in Netherlands. Then in the navigation menu, select Data &gt; Databases, choose <code>GEOLAB.GEOMETRY</code>, and click Create &gt; Stage &gt; Snowflake Managed.</p>
<p class="image-container"><img src="img/add7662d1564c87d.png"></p>
<p>In the new Window, use the name stageshp and click <code>Create</code>.</p>
<p class="image-container"><img style="width: 500.00px" src="img/2bda279fad7bd118.png"></p>
<p>Then select newly created Stage and click <code>+ Files</code> to upload a new file.</p>
<p class="image-container"><img src="img/9a54d73eebd0a218.png"></p>
<p>Browse the file you just downloaded and click  <code>Upload</code>.</p>
<p>To load that data we will use Python UDF that reads data from Shapefile .</p>
<p>Run the following query that creates a UDF:</p>
<pre><code>CREATE OR REPLACE FUNCTION PY_LOAD_GEODATA(PATH_TO_FILE string, filename string)
RETURNS TABLE (wkt varchar, properties object)
LANGUAGE PYTHON
RUNTIME_VERSION = 3.8
PACKAGES = (&#39;fiona&#39;, &#39;shapely&#39;, &#39;snowflake-snowpark-python&#39;)
HANDLER = &#39;GeoFileReader&#39;
AS $$
from shapely.geometry import shape
from snowflake.snowpark.files import SnowflakeFile
from fiona.io import ZipMemoryFile
class GeoFileReader:        
    def process(self, PATH_TO_FILE: str, filename: str):
    	with SnowflakeFile.open(PATH_TO_FILE, &#39;rb&#39;) as f:
    		with ZipMemoryFile(f) as zip:
    			with zip.open(filename) as collection:
    				for record in collection:
    					yield (shape(record[&#39;geometry&#39;]).wkt, dict(record[&#39;properties&#39;]))
$$;
</code></pre>
<p>This UDF reads a shapefile and returns its content as a table. Under the hood it uses geospatial libraries <code>fiona</code> and <code>shapely</code>. Run the following query to see the content of the uploaded shapefile.</p>
<pre><code>// Setting EWKT as an output format
ALTER SESSION SET geometry_output_format = &#39;EWKT&#39;;

SELECT to_geometry(wkt) AS geometry,
       (case when properties:TYPE_1::string is null then &#39;Municipality&#39; else &#39;Province&#39; end) as type,
       properties:NAME_1::string as province_name,
       properties:NAME_2::string as municipality_name
FROM table(PY_LOAD_GEODATA(build_scoped_file_url(@stageshp, &#39;nl_areas.zip&#39;), &#39;nl_areas.shp&#39;));
</code></pre>
<p>This query fails with the the error: <em>Geometry validation failed: Geometry has invalid self-intersections. A self-intersection point was found at (559963, 5.71069e+06)</em>.</p>
<aside class="warning"><p> The constructor function determines if the shape is valid according to the <a href="https://www.ogc.org/standards/sfa" target="_blank">Open Geospatial Consortium&#39;s Simple Feature Access / Common Architecture</a> standard. If the shape is invalid, the function reports an error and does not create the GEOMETRY object. That is what happened in our example.</p>
</aside>
<p>To fix this we can allow ingestion of invalid shape by setting the corresponding parameter to True. Let&#39;s run the SELECT statement again, but update the query to see how many shapes are invalid. Run the following query:</p>
<pre><code>SELECT to_geometry(wkt, True) AS geometry,
       st_isvalid(geometry) as is_valid,
       (case when properties:TYPE_1::string is null then &#39;Municipality&#39; else &#39;Province&#39; end) as type,
       properties:NAME_1::string as province_name,
       properties:NAME_2::string as municipality_name
FROM table(PY_LOAD_GEODATA(build_scoped_file_url(@stageshp, &#39;nl_areas.zip&#39;), &#39;nl_areas.shp&#39;))
ORDER BY is_valid ASC;
</code></pre>
<p class="image-container"><img src="img/c4163b7772109e66.png"></p>
<p>This query completed without error and now you see that the shape of the province Zeeland is invalid. Let&#39;s try to repair it by applying <a href="https://docs.snowflake.com/en/sql-reference/functions/st_buffer" target="_blank">ST_BUFFER</a> function with a small value of the distance.</p>
<pre><code>SELECT st_buffer(to_geometry(wkt, True), -1) AS geometry,
       st_isvalid(geometry) as is_valid,
       (case when properties:TYPE_1::string is null then &#39;Municipality&#39; else &#39;Province&#39; end) as type,
       properties:NAME_1::string as province_name,
       properties:NAME_2::string as municipality_name
FROM table(PY_LOAD_GEODATA(build_scoped_file_url(@stageshp, &#39;nl_areas.zip&#39;), &#39;nl_areas.shp&#39;))
ORDER BY is_valid ASC;
</code></pre>
<p class="image-container"><img src="img/52ee359ebe451079.png"></p>
<aside class="warning"><p> The ST_BUFFER with some small positive or negative value for the distance <em>sometimes</em> can help to fix invalid shapes. However, you should remember that the unit of measurement for the distance parameter in the ST_BUFFER will be the same as your data. Therefore, if your data utilizes lon/lat values, the distance&#39;s units will also be degrees.</p>
</aside>
<p>Now all shapes are valid and the data ready to be ingested. One additional thing we should do is to set SRID, since othervise it will be set to 0. This dataset is in the reference system <a href="https://epsg.io/32231" target="_blank">WGS 72 / UTM zone 31N</a>, so it makes sense to add the SRID=32231 to the constructor function.</p>
<p>Run the following query:</p>
<pre><code>CREATE OR REPLACE TABLE geolab.geometry.nl_administrative_areas AS
SELECT ST_BUFFER(TO_GEOMETRY(wkt, 32231, True), -1) AS geometry,
       (case when properties:TYPE_1::string is null then &#39;Municipality&#39; else &#39;Province&#39; end) AS type,
       properties:NAME_1::string AS province_name,
       properties:NAME_2::string AS municipality_name
FROM TABLE(PY_LOAD_GEODATA(build_scoped_file_url(@stageshp, &#39;nl_areas.zip&#39;), &#39;nl_areas.shp&#39;));
</code></pre>
<p>Excellent! Now that all the datasets are successfully loaded, let&#39;s proceed to the next exciting step: the analysis.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Spatial analysis" duration="25">
        <p>To showcase the capabilities of the GEOMETRY data type, we will explore several use cases. In these scenarios, we&#39;ll assume we are analysts working for an energy utilities company responsible for maintaining electrical grids.</p>
<h2 is-upgraded>What is the length of the electricity cables?</h2>
<p>In the first use case we will calculate the length of electrical cables our organization is responsible for in each administrative area within the Netherlands. We&#39;ll be utilizing two datasets: with power infrastructure of the Netherlands and the borders of Dutch administrative areas. First, let&#39;s check the sample of each dataset.</p>
<p>Run the following query to see the content of NL_CABLES_STATIONS table:</p>
<pre><code>SELECT geometry,
       TYPE
FROM GEOLAB.GEOMETRY.NL_CABLES_STATIONS
LIMIT 5;
</code></pre>
<p>The results look similar to this:</p>
<p class="image-container"><img src="img/9e56eacc51a5f1c5.png"></p>
<p>The spatial data is stored using the <code>GEOMETRY</code> data type and employs the Dutch mapping system, <code>Amersfoort / RD New</code> (SRID = 28992). To view the contents of the table containing the boundaries of the administrative areas in the Netherlands, execute the following query:</p>
<pre><code>SELECT *
FROM geolab.geometry.nl_administrative_areas
LIMIT 5;
</code></pre>
<p class="image-container"><img src="img/786862e2fa0f393.png"></p>
<p>In order to compute the length of all cables per administrative area, it&#39;s essential that both datasets adhere to the same mapping system. We have two options: either re-project <code>nl_administrative_areas</code> to SRID 28992, or reproject <code>nl_cables_stations</code> to SRID 32231. For this exercise, let&#39;s choose the first option.</p>
<p>Run the following query:</p>
<pre><code>SELECT t1.province_name,
       sum(st_length(t2.geometry)) AS cables_length
FROM geolab.geometry.nl_administrative_areas t1,
     geolab.geometry.nl_cables_stations t2
WHERE st_intersects(st_transform(t1.geometry, 28992), t2.geometry)
  AND t1.type = &#39;Province&#39;
GROUP BY 1
ORDER BY 2 DESC;
</code></pre>
<p class="image-container"><img src="img/c90a97a11144a45b.png"></p>
<p>We have five areas densely covered by electicity cables, those are the ones that our company is responsible for. For our first analysis, we will focus on these areas.</p>
<h2 is-upgraded>What cell towers lacking electricity cables nearby</h2>
<p>In many areas, especially rural or remote ones, cell towers might be located far from electricity grids. This can pose a challenge in providing a reliable power supply to these towers. They often rely on diesel generators, which can be expensive to operate and maintain and have environmental implications. Furthermore, power outages can lead to disruptions in mobile connectivity, impacting individuals, businesses, and emergency services.</p>
<p>Our analysis aims to identify mobile cell towers that are not near an existing electricity grid. This information could be used to prioritize areas for grid expansion, to improve the efficiency of renewable energy source installations (like solar panels or wind turbines), or to consider alternative energy solutions.</p>
<p>For this and the next examples let&#39;s use GEOGRAPHY data type as it can be easyly visualized using CARTO. As a first step, let&#39;s create GEOGRAPHY equivalents for energy grids and boundaries table. For that we need to reproject GEOMETRY column in each of the tables into mapping system WGS 84 (SRID=4326) and then convert to GEOGRAPHY data type. Run following queries that create new tables and enable search optimization for each of them in order to iincrease the performance of spatial operations.</p>
<pre><code>// Creating a table with GEOGRAPHY for nl_administrative_areas
CREATE OR REPLACE SCHEMA GEOLAB.GEOGRAPHY;

CREATE OR REPLACE TABLE geolab.geography.nl_administrative_areas AS
SELECT to_geography(st_asgeojson(st_transform(geometry, 4326))) AS geom,
       type,
       province_name,
       municipality_name
FROM geolab.geometry.nl_administrative_areas
ORDER BY ST_GEOHASH(geom);

ALTER TABLE geolab.geography.nl_administrative_areas ADD SEARCH optimization ON GEO(geom);

// Creating a table with GEOGRAPHY for nl_cables_stations
CREATE OR REPLACE TABLE geolab.geography.nl_cables_stations AS
SELECT to_geography(st_asgeojson(st_transform(geometry, 4326))) AS geom,
       id,
       type
FROM geolab.geometry.nl_cables_stations
ORDER BY ST_GEOHASH(geom);

ALTER TABLE geolab.geography.nl_cables_stations ADD SEARCH OPTIMIZATION ON GEO(geom);
</code></pre>
<p>We can now go to the CARTO account and visualize administrative areas and cables information in CARTO Builder.</p>
<ul>
<li>Create a new map. Use the navigation menu on the left to get to Maps and then click on (+) New Map.</li>
</ul>
<p class="image-container"><img style="width: 700.00px" src="img/e28b8c7ec75b2f9b.png"></p>
<ul>
<li>Click on the <code>Add Source From</code> → <code>Data Explorer</code></li>
</ul>
<p class="image-container"><img style="width: 700.00px" src="img/bfb7d2211a563fa0.png"></p>
<ul>
<li>In the pop-up select your connection and the <code>GEOLAB.GEOGRAPHY.NL_ADMINISTRATIVE_AREAS</code> table.</li>
</ul>
<p class="image-container"><img style="width: 700.00px" src="img/1b3b28d62721b9e3.png"></p>
<p>Click on the newly created layer and unselect &#34;Fill Color&#34; toggle to see the boundaries of the areas on the map.</p>
<p class="image-container"><img style="width: 700.00px" src="img/85de02821f24aae5.gif"></p>
<p>Similarly you can visualize <code>GEOLAB.GEOGRAPHY.NL_CABLES_STATIONS</code> table.</p>
<p class="image-container"><img style="width: 700.00px" src="img/19bdb949965fad64.gif"></p>
<p>Now you will create a table with locations of cell towers stored as GEOGRAPHY and enable search optimization, just like for the previous two tables.  Run the following query in your Snowflake&#39;s worksheet:</p>
<pre><code>// Creating a new schema for GEOGRAPHY
CREATE OR REPLACE TABLE geolab.geography.nl_4g AS
SELECT DISTINCT st_point(lon, lat) AS geom,
                radio,
                cell_range
FROM OPENCELLID.PUBLIC.RAW_CELL_TOWERS t1
WHERE mcc = &#39;204&#39; -- 204 is the mobile country code in the Netherlands
ORDER BY ST_GEOHASH(geom);

ALTER TABLE geolab.geography.nl_4g ADD SEARCH OPTIMIZATION ON GEO(geom); 
</code></pre>
<p>Finally, we will find all cell towers that don&#39;t have an energy line within a 2-kilometer radius. For each cell tower we&#39;ll calculate the distance to the nearest electricity cable. In CARTO Builder click on the Add <code>Source From</code> → <code>Custom Query (SQL)</code> and make sure you have selected Snowflake Connection that you have created in previous steps.</p>
<p class="image-container"><img style="width: 700.00px" src="img/b3eb977704672d7e.gif"></p>
<p>Then paste the following query and click on the green <code>Run</code> button.</p>
<pre><code>SELECT province_name,
       cells.geom
FROM geolab.geography.nl_4g cells
LEFT JOIN geolab.geography.nl_cables_stations cables 
     ON st_dwithin(cells.geom, cables.geom, 2000)
JOIN geolab.geography.nl_administrative_areas areas 
     ON st_contains(areas.geom, cells.geom)
WHERE cells.radio=&#39;LTE&#39;
  AND areas.type = &#39;Province&#39;
  AND areas.province_name in (&#39;Noord-Brabant&#39;, &#39;Overijssel&#39;, &#39;Limburg&#39;, &#39;Groningen&#39;, &#39;Drenthe&#39;)
  AND cables.geom IS NULL;
</code></pre>
<p>You can modify the colors of cell towers in the output and expand their radius in order to enhance their visibility.</p>
<p class="image-container"><img style="width: 700.00px" src="img/310ea6817361a60f.gif"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Advanced Analysis using Spatial Joins and H3" duration="20">
        <p>In the previous section you&#39;ve found cell cell towers that don&#39;t have electicity cables nearby. But what about answering more sophisticated questions, like what areas in Netherlands have very good and bad coverage by LTE (4G) network? You can use geospatial functions combined with spatial join and H3 functions from Carto toolbox to find out.</p>
<h2 is-upgraded>What municipalities in Netherlands have good/poor LTE coverage?</h2>
<p>You have been using <code>NL_CELLTOWERS</code> table, which stores the locations of cell towers. To find municipalities in Netherlans with good and bad coverage by LTE network, we will undertake a two-step process as follows:</p>
<ul>
<li>For every LTE cell tower, we will calculate the coverage area.</li>
<li>For every Dutch municipality, calculate the area covered by LTE network.</li>
</ul>
<p><code>ST_BUFFER</code> from the Carto toolbox can be used to calculate the coverage area for each LTE cell tower. In <code>NL_CELLTOWERS</code> table, there is a field <em>cell_range</em> which can be used as a value of radius in ST_BUFFER. For the sake of this example we will assume that a good signal can be received no further than 2000 meters away from the LTE cell.</p>
<p>Run the following two queries in your Snowflake&#39;s worksheet:</p>
<pre><code>CREATE OR REPLACE TABLE geolab.geography.nl_celltowers AS
SELECT geom,
       radio,
       cell_range,
       carto.carto.st_buffer(geom, least(cell_range, 2000), 5) AS coverage
FROM geolab.geography.nl_4g
WHERE radio = &#39;LTE&#39;
ORDER BY ST_GEOHASH(geom);

ALTER TABLE geolab.geography.nl_celltowers ADD SEARCH OPTIMIZATION ON GEO(geom); 
</code></pre>
<p>Now there is a new columns <code>coverage</code> with areas that correspond to the coverage areas of the cell towers. Let&#39;s create a new map in the CARTO Builder and run the following query to visualize the coverage for one of the municipalities:</p>
<pre><code>SELECT c.coverage AS geom
FROM geolab.geography.nl_celltowers c
JOIN geolab.geography.nl_administrative_areas AS b 
  ON st_intersects(b.geom, c.geom)
WHERE TYPE = &#39;Municipality&#39;
  AND municipality_name = &#39;Angerlo&#39;;
</code></pre>
<p>The result of this query is a number of overlapping circles:</p>
<p class="image-container"><img style="width: 700.00px" src="img/727b48d1c2e3c6df.gif"></p>
<p>To calculate the coverage of each district by LTE network, you can create a user-defined Python function that calculates an aggregated union and uses the Shapely library under the hood.</p>
<p>Run the following query from Snowflake Worksheets:</p>
<pre><code>CREATE OR REPLACE FUNCTION PY_UNION_AGG(g1 array)
RETURNS GEOGRAPHY
LANGUAGE PYTHON
RUNTIME_VERSION = 3.8
PACKAGES = (&#39;shapely&#39;)
HANDLER = &#39;udf&#39;
AS $$
from shapely.ops import unary_union
from shapely.geometry import shape, mapping
def udf(g1):
    shape_union = unary_union([shape(i) for i in g1])
    return mapping(shape_union)
$$;
</code></pre>
<p>The function above gets an array of spatial objects and &#34;dissolves&#34; them in one large shape which is a union of all initial shapes.</p>
<p>Now run the following query from the CARTO Builder:</p>
<pre><code>SELECT PY_UNION_AGG(ARRAY_AGG(st_asgeojson(c.coverage))) as geom
FROM geolab.geography.nl_celltowers c
JOIN geolab.geography.nl_administrative_areas AS b 
  ON st_intersects(b.geom, c.geom)
WHERE type = &#39;Municipality&#39;
AND municipality_name = &#39;Angerlo&#39;;
</code></pre>
<p>Note how the result of this function return a single polygon covering the same area without overlaps.</p>
<p class="image-container"><img style="width: 700.00px" src="img/8a7159d9415eec4c.png"></p>
<p>Let&#39;s now for every municipality compute the following:</p>
<ul>
<li>The area that is covered by the LTE network</li>
<li>The numerical value of coverage ratio by the LTE network</li>
</ul>
<p>Use the table <code>nl_celltowers</code>, and first join it with <code>nl_administrative_areas</code> using <code>ST_INTERSECTS</code> predicate to match cell towers to the municipalities they cover. Then we use <code>PY_UNION_AGG</code> to get a combined coverage polygon. Then use <code>ST_INTERSECTION</code> to find an portion of the municipality that is covered by the LTE signal. Then we compute the covered area in square meters. The result will be saved in the new table. To speed up queries against that newly created table, you will enable the search optimization feature.</p>
<p>Run the following two queries:</p>
<pre><code>CREATE OR REPLACE TABLE geolab.geography.nl_municipalities_coverage AS
SELECT municipality_name,
       TO_GEOGRAPHY(ST_ASGEOJSON(geom)) AS municipality_geom,
       ST_INTERSECTION(ANY_VALUE(geom), PY_UNION_AGG(ARRAY_AGG(ST_ASGEOJSON(coverage)))) AS coverage_geom,
       ROUND(ST_AREA(coverage_geom)/ST_AREA(ANY_VALUE(geom)), 2) AS coverage_ratio
FROM
  (SELECT c.coverage AS coverage,
          b.municipality_name AS municipality_name,
          b.geom
   FROM geolab.geography.nl_celltowers AS c
   INNER JOIN geolab.geography.nl_administrative_areas AS b 
      ON ST_INTERSECTS(b.geom, c.coverage)
   WHERE TYPE = &#39;Municipality&#39;)
GROUP BY 1, 2
ORDER BY ST_GEOHASH(geom);

ALTER TABLE geolab.geography.nl_municipalities_coverage ADD SEARCH OPTIMIZATION ON GEO(geom);
</code></pre>
<p>Nice! Now you have a <code>NL_MUNICIPALITIES_COVERAGE</code> table that contains the name of the municipality, the boundaries of that municipality, and the boundaries of the LTE coverage area. Let&#39;s vizualize this in Carto. Paste the following query into the SQL editor and use <code>COVERAGE_RATIO</code> column to color code the coverage areas.</p>
<pre><code>SELECT coverage_geom as geom,
       coverage_ratio
FROM geolab.geography.nl_municipalities_coverage;
</code></pre>
<p class="image-container"><img style="width: 700.00px" src="img/2e280ee86de4fe07.gif"></p>
<h2 is-upgraded>What percent of the Dutch highways have LTE coverage?</h2>
<p>Now imagine you want to calculate what percentage of highways in Netherlands are covered by LTE network. To get the number, you can employ the <code>Netherlands Open Map Data</code> dataset that has NL motorways.</p>
<p>Run the foillowing query in your Snowflake worksheet:</p>
<pre><code>SELECT SUM(ST_LENGTH(ST_INTERSECTION(coverage.coverage_geom, roads.geo_cordinates))) as covered_length,
       SUM(ST_LENGTH(ST_INTERSECTION(coverage.municipality_geom, roads.geo_cordinates))) as total_length,
       ROUND(100 * covered_length / total_length, 2) AS &#34;Coverage, %&#34;
FROM OSM_NL.NETHERLANDS.V_ROAD roads,
     geolab.geography.nl_municipalities_coverage coverage
WHERE ST_INTERSECTS(coverage.municipality_geom, roads.geo_cordinates)
AND class in (&#39;primary&#39;, &#39;motorway&#39;);
</code></pre>
<p>It seems our LTE network covers almost 100% of the highways. A good number to call out in a marketing campaign.</p>
<h2 is-upgraded>Estimating quality of LTE signal on Dutch highways</h2>
<p>In the previous section we found outs that almost all highways in Netetherlands are within a range of LTE tower. But the LTE signal may have a different quality depeneding on how close is the tower or how many towers we have. The next question you may ask as an analyis is what motorways in the NL have poor signal quality.</p>
<p>For this we need to build a signal decay model. We will also H3 to represents signal distribution around the cell towers. H3 functions from <code>CARTO's Analytics Toolbox</code> will help us with that.</p>
<p>In the following query, we will create a table with an H3 cell id for each cell tower. To get the H3 cell id, we will use the <code>H3_FROMGEOGPOINT</code> function:</p>
<pre><code>CREATE OR REPLACE TABLE geolab.geography.nl_lte AS
SELECT row_number() over(ORDER BY NULL) AS id,
       cell_range,
       carto.carto.H3_FROMGEOGPOINT(geom, 9) AS h3
FROM geolab.geography.nl_celltowers
WHERE radio = &#39;LTE&#39;
ORDER BY h3;
</code></pre>
<p>Now that we know H3 cell for each LTE tower we can find it&#39;s neighboring H3 cells and estimate signal strength in them. First, we will apply the <code>H3_KRING</code> function to compute all neighboring H3 cells within a certain distance from a given H3 cell. The distance is calculated by dividing the <code>CELL_RANGE</code> by 586 meters, which represents the spacing between H3 cells at resolution 9.  Since <code>H3_KRING</code> yields an array, we must use the lateral joing to flatten these array.</p>
<p>Then we will create a decay function based on the H3 distance, so we need to determine the maximum H3 distance for each antenna. We can then group the data by H3 cell and choose the highest signal strength within that cell. Multiple towers can cover the same H3 cell multiple times; thus, we will select the one with the strongest signal.</p>
<p>The signal will range from 0 (poor) to 100 (strongest). The model multiplies the &#34;starting signal strength&#34; of 100 by the distance between the antenna and the H3 cell, and it adds more noise as the H3 cell is further away.</p>
<p>Clustering by H3 will enable CARTO to execute queries faster, which is beneficial for visualization purposes.</p>
<p>Run the following query:</p>
<pre><code language="language-plaintext" class="language-plaintext">CREATE OR REPLACE TABLE geolab.geography.nl_lte_coverage_h3 AS
// First estimate max distance in H3 cells
WITH nl_lte AS (
    SELECT *,
           ROUND(LEAST(nl_lte.cell_range, 2000) / 586)::INT AS h3_max_distance
    FROM geolab.geography.nl_lte
),
// Find all neigbouring cells and calculate signal strength
h3_neighbors AS (
    SELECT id,
          p.value::string AS h3,
          carto.carto.h3_distance(h3, p.value)::int AS h3_distance,
          CEIL(LEAST(nl_lte.cell_range, 2000) / 586)::int AS h3_max_distance, 
          // decay model for signal strength:
          100 * pow(1 - h3_distance / (h3_max_distance + 1), 2) AS signal_strength
   FROM geolab.geography.nl_lte nl_lte,
        table(flatten(INPUT =&gt; CARTO.CARTO.H3_KRING(nl_lte.h3, h3_max_distance))) p)
SELECT h3, 
// maxiumum signal strength with noise:
       MAX(signal_strength) * UNIFORM(0.8, 1::float, random()) AS signal_strength
FROM h3_neighbors
GROUP BY h3
ORDER BY h3;
</code></pre>
<p>Now that we have created our signal decay model, let&#39;s visualize it in CARTO. For that, we can just run the following query from the query console into a new map.</p>
<pre><code>SELECT h3,
       signal_strength
FROM geolab.geography.nl_lte_coverage_h3;
</code></pre>
<aside class="special"><p> Note that we don&#39;t have a <code>GEOGRAPHY</code> on this query. This is because CARTO has native support of H3 and can show the H3 geography representation on the browser without the need to store and move the geography from the database to the browser.</p>
</aside>
<p>As we create an H3 layer we will need to configure the layer type from the query console:</p>
<p class="image-container"><img style="width: 700.00px" src="img/d1c38dc0de2bf966.gif"></p>
<p>H3 layers allow us to show aggregated information at different resolutions for different zoom levels. Because of this, when we style the layer, we need to decide an aggregation method for the attribute to show, in this example we will use <code>SIGNAL_STRENGTH</code>.</p>
<p class="image-container"><img style="width: 700.00px" src="img/949967917cf09385.png"></p>
<p>Remember to select a color palette of your liking and the color scale (the default is custom but we want to <em>Quantize</em> bins for this use case). We can also change the relation between the zoom level and the resolution. The higher the resolution configuration, the more granularity we will see on the map but it will also take longer to load. Select resolution 5.</p>
<p class="image-container"><img style="width: 700.00px" src="img/d8af3dd44b69ac85.gif"></p>
<p>Let&#39;s now use the road network from <code>NL Open Map Data</code> to see which road segments have good coverage and which do not. To intersect the road layer with the H3 signal strength layer we need to find H3 cells covering all motorways in the NL.</p>
<p>The query below demonstrates one way of doing this. First we split the road geometries into simple segments and compute the H3 index for in the middle of each segment. Then we aggregate all segments back. Run the following query:</p>
<pre><code language="language-plaintext" class="language-plaintext">CREATE OR REPLACE TABLE GEOLAB.GEOGRAPHY.NL_ROADS_H3 AS 
// import roads from OSM:
WITH roads AS
  (SELECT row_number() over(
                            ORDER BY NULL) AS road_id,
          geo_cordinates AS geom
   FROM OSM_NL.NETHERLANDS.V_ROAD roads
   WHERE class in (&#39;primary&#39;, &#39;motorway&#39;)
     AND st_dimension(geo_cordinates) = 1),
// In order to compute H3 cells corresponding to each road we need to first
// split roads into the line segments. We do it using the ST_POINTN function
     segments AS
  (SELECT road_id,
          value::integer AS segment_id,
          st_makeline(st_pointn(geom, segment_id), st_pointn(geom, segment_id + 1)) AS SEGMENT,
          geom,
          carto.carto.h3_fromgeogpoint(st_centroid(SEGMENT), 9) AS h3_center
   FROM roads,
        LATERAL flatten(ARRAY_GENERATE_RANGE(1, st_npoints(geom)))) 
// Next table build the H3 cells covering the roads
// For each line segment we find a corresponding H3 cell and then agggerate by road id and H3
// At this point we switched from segments to H3 cells covering the roads.
SELECT road_id,
       h3_center AS h3,
       any_value(geom) AS road_geometry
FROM segments
GROUP BY 1, 2
ORDER BY h3;
</code></pre>
<p>If you visualize table <code>GEOLAB.GEOGRAPHY.NL_ROADS_H3</code> in CARTO Builder (<code>Add Source From</code> → <code>Data Explorer</code>) you will see tesselated roads.</p>
<p class="image-container"><img style="width: 700.00px" src="img/8ea263af014219f4.png"></p>
<p>Now we use signal decay model that we&#39;ve build privously to estimate the average signal along each highway. For this we need to join two tables (tesselated highways and the signal strenght) using H3 cell id and aggregate the result by road id.</p>
<p>Run the following two queries.</p>
<pre><code language="language-plaintext" class="language-plaintext">CREATE OR REPLACE TABLE geolab.geography.osm_nl_not_covered AS
SELECT road_id,
       ANY_VALUE(road_geometry) AS geom,
       AVG(IFNULL(signal_strength, 0.0)) AS avg_signal_strength,
       IFF(avg_signal_strength &gt;= 50, &#39;OK Signal&#39;, &#39;No Signal&#39;) AS signal_category
FROM GEOLAB.GEOGRAPHY.NL_ROADS_H3 roads_h3
LEFT JOIN GEOLAB.GEOGRAPHY.NL_LTE_COVERAGE_H3 cells ON roads_h3.h3 = cells.h3
GROUP BY road_id
ORDER BY ST_GEOHASH(geom);

ALTER TABLE geolab.geography.osm_nl_not_covered ADD SEARCH OPTIMIZATION ON GEO(geom);
</code></pre>
<p>Now that we have classified road segments by signal and no signal, we can run the following simple query to get the length of each geography in meters:</p>
<pre><code>SELECT signal_category,
       SUM(ST_LENGTH(geom)/1000)::int AS total_km
FROM geolab.geography.osm_nl_not_covered
GROUP BY signal_category;
</code></pre>
<p>We now know that we have 13,938 km with good coverage and 2,331 with poor/no coverage. Interestingly, that is about 15 % of the NL roads!</p>
<p>Lastly, with this layer, we can add it to our CARTO map and visualize the road segment according to the <code>SIGNAL_CATEGORY</code> feature we created.</p>
<p>For this, we can add the layer via <code>Add source from</code> → <code>Data Explorer</code>. Then select your connection and the <code>GEOLAB.GEOGRAPHY.OSM_NL_NOT_COVERED</code> table.</p>
<p class="image-container"><img style="width: 700.00px" src="img/64af56a42ce4f1a6.png"></p>
<p>Once we have our second layer on the map, we can click on it to style it and show the stroke color based on our <code>SIGNAL_CATEGORY</code> column. For that create a &#34;Custom palette&#34; with just two colors: gray for roads with good signal and red for roads with no/poor signal.</p>
<p class="image-container"><img style="width: 700.00px" src="img/abde289037d75a3e.gif"></p>
<aside class="special"><p> You may feel that these last several queries were a bit long and repetitive, but remember that the intention of this guide was to walk you through the progression of building these longer, more complicated queries by illustrating to you what happens at each step through the progression. By understanding how functions can be combined, it helps you to understand how you can do more advanced things with Snowflake geospatial features!</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Conclusion" duration="0">
        <p>In this guide, you acquired geospatial data from the Snowflake Marketplace, explored how the GEOMETRY data type works and how it differs from the GEOGRAPHY. You converted one data type into another and queried geospatial data using parser, constructor, transformation, calculation and H3 functions on single tables and multiple tables with joins. You then saw how geospatial objects could be visualized using CARTO.</p>
<p>You are now ready to explore the larger world of Snowflake geospatial support and geospatial functions.</p>
<h2 class="checklist" is-upgraded>What we&#39;ve covered</h2>
<ul class="checklist">
<li>How to acquire a shared database from the Snowflake Marketplace and from External and internal storages.</li>
<li>The GEOMETRY data type, its formats GeoJSON, WKT, EWKT, WKB, and EWKB, and how to switch between them.</li>
<li>How to use constructors like TO_GEOMETRY, ST_MAKELINE.</li>
<li>How to reproject between SRIDs using ST_TRANSFORM.</li>
<li>How to perform relational calculations like ST_DWITHIN and ST_INTERSECTS.</li>
<li>How to perform measurement calculations like ST_LENGTH.</li>
<li>How to use set operations like ST_INTERSECTION.</li>
<li>How to use Python UDFs for reading Shapefiles and creating custom functions.</li>
<li>How to use Spatial grid and H3 functions like H3_FROMGEOGPOINT, H3_KRING, H3_POLYFILL.</li>
<li>How to use Search Optimization to speed up geospatial queries.</li>
</ul>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/native-shim.js"></script>
  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/custom-elements.min.js"></script>
  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/prettify.js"></script>
  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>
  <script type="text/javascript">
    window.heap=window.heap||[],heap.load=function(e,t){window.heap.appid=e,window.heap.config=t=t||{};var r=t.forceSSL||"https:"===document.location.protocol,a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src=(r?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+e+".js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(a,n);for(var o=function(e){return function(){heap.push([e].concat(Array.prototype.slice.call(arguments,0)))}},p=["addEventProperties","addUserProperties","clearEventProperties","identify","removeEventProperty","setEventProperties","track","unsetEventProperty"],c=0;c<p.length;c++)heap[p[c]]=o(p[c])};
    heap.load("2025084205");
  </script>
</body>
</html>
